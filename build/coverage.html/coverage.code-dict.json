{"/home/travis/build/npmtest/node-npmtest-tedious/test.js":"/* istanbul instrument in package npmtest_tedious */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-tedious/lib.npmtest_tedious.js":"/* istanbul instrument in package npmtest_tedious */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_tedious = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_tedious = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-tedious/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-tedious && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_tedious */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_tedious\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught.stack);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_tedious.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_tedious.rollup.js'] =\n            local.assetsDict['/assets.npmtest_tedious.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_tedious.__dirname +\n                    '/lib.npmtest_tedious.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-tedious/tedious/lib/tedious.js":"'use strict';\n\nmodule.exports.BulkLoad = require('./bulk-load');\nmodule.exports.Connection = require('./connection');\nmodule.exports.Request = require('./request');\nmodule.exports.library = require('./library');\n\nmodule.exports.ConnectionError = require('./errors').ConnectionError;\nmodule.exports.RequestError = require('./errors').RequestError;\n\nmodule.exports.TYPES = require('./data-type').typeByName;\nmodule.exports.ISOLATION_LEVEL = require('./transaction').ISOLATION_LEVEL;\nmodule.exports.TDS_VERSION = require('./tds-versions').versions;","/home/travis/build/npmtest/node-npmtest-tedious/tedious/lib/bulk-load.js":"'use strict';\n\nvar _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = require('babel-runtime/helpers/inherits');\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar EventEmitter = require('events').EventEmitter;\nvar WritableTrackingBuffer = require('./tracking-buffer/tracking-buffer').WritableTrackingBuffer;\nvar TOKEN_TYPE = require('./token/token').TYPE;\n\nvar FLAGS = {\n  nullable: 1 << 0,\n  caseSen: 1 << 1,\n  updateableReadWrite: 1 << 2,\n  updateableUnknown: 1 << 3,\n  identity: 1 << 4,\n  computed: 1 << 5, // introduced in TDS 7.2\n  fixedLenCLRType: 1 << 8, // introduced in TDS 7.2\n  sparseColumnSet: 1 << 10, // introduced in TDS 7.3.B\n  hidden: 1 << 13, // introduced in TDS 7.2\n  key: 1 << 14, // introduced in TDS 7.2\n  nullableUnknown: 1 << 15 // introduced in TDS 7.2\n};\n\nvar DONE_STATUS = {\n  FINAL: 0x00,\n  MORE: 0x1,\n  ERROR: 0x2,\n  INXACT: 0x4,\n  COUNT: 0x10,\n  ATTN: 0x20,\n  SRVERROR: 0x100\n};\n\nmodule.exports = function (_EventEmitter) {\n  (0, _inherits3.default)(BulkLoad, _EventEmitter);\n\n  function BulkLoad(table, options1, callback) {\n    (0, _classCallCheck3.default)(this, BulkLoad);\n\n    var _this = (0, _possibleConstructorReturn3.default)(this, (BulkLoad.__proto__ || (0, _getPrototypeOf2.default)(BulkLoad)).call(this));\n\n    _this.error = undefined;\n    _this.canceled = false;\n\n    _this.table = table;\n    _this.options = options1;\n    _this.callback = callback;\n    _this.columns = [];\n    _this.columnsByName = {};\n    _this.rowsData = new WritableTrackingBuffer(1024, 'ucs2', true);\n    _this.firstRowWritten = false;\n    return _this;\n  }\n\n  (0, _createClass3.default)(BulkLoad, [{\n    key: 'addColumn',\n    value: function addColumn(name, type, options) {\n      if (options == null) {\n        options = {};\n      }\n\n      if (this.firstRowWritten) {\n        throw new Error('Columns cannot be added to bulk insert after the first row has been written.');\n      }\n\n      var column = {\n        type: type,\n        name: name,\n        value: null,\n        output: options.output || (options.output = false),\n        length: options.length,\n        precision: options.precision,\n        scale: options.scale,\n        objName: options.objName || name,\n        nullable: options.nullable\n      };\n\n      if ((type.id & 0x30) === 0x20) {\n        if (column.length == undefined && type.resolveLength) {\n          column.length = type.resolveLength(column);\n        }\n      }\n\n      if (type.hasPrecision) {\n        if (column.precision == undefined && type.resolvePrecision) {\n          column.precision = type.resolvePrecision(column);\n        }\n      }\n\n      if (type.hasScale) {\n        if (column.scale == undefined && type.resolveScale) {\n          column.scale = type.resolveScale(column);\n        }\n      }\n\n      this.columns.push(column);\n\n      return this.columnsByName[name] = column;\n    }\n  }, {\n    key: 'addRow',\n    value: function addRow(row) {\n      this.firstRowWritten = true;\n\n      if (arguments.length > 1 || !row || typeof row !== 'object') {\n        // convert arguments to array in a way the optimizer can handle\n        var arrTemp = new Array(arguments.length);\n        for (var i = 0, len = arguments.length; i < len; i++) {\n          var c = arguments[i];\n          arrTemp[i] = c;\n        }\n        row = arrTemp;\n      }\n\n      // write row token\n      this.rowsData.writeUInt8(TOKEN_TYPE.ROW);\n\n      // write each column\n      var arr = row instanceof Array;\n      for (var _i = 0, _len = this.columns.length; _i < _len; _i++) {\n        var _c = this.columns[_i];\n        _c.type.writeParameterData(this.rowsData, {\n          length: _c.length,\n          scale: _c.scale,\n          precision: _c.precision,\n          value: row[arr ? _i : _c.objName]\n        }, this.options);\n      }\n    }\n  }, {\n    key: 'getBulkInsertSql',\n    value: function getBulkInsertSql() {\n      var sql = 'insert bulk ' + this.table + '(';\n      for (var i = 0, len = this.columns.length; i < len; i++) {\n        var c = this.columns[i];\n        if (i !== 0) {\n          sql += ', ';\n        }\n        sql += '[' + c.name + '] ' + c.type.declaration(c);\n      }\n      sql += ')';\n      return sql;\n    }\n  }, {\n    key: 'getTableCreationSql',\n    value: function getTableCreationSql() {\n      var sql = 'CREATE TABLE ' + this.table + '(\\n';\n      for (var i = 0, len = this.columns.length; i < len; i++) {\n        var c = this.columns[i];\n        if (i !== 0) {\n          sql += ',\\n';\n        }\n        sql += '[' + c.name + '] ' + c.type.declaration(c);\n        if (c.nullable !== undefined) {\n          sql += ' ' + (c.nullable ? 'NULL' : 'NOT NULL');\n        }\n      }\n      sql += '\\n)';\n      return sql;\n    }\n  }, {\n    key: 'getPayload',\n    value: function getPayload() {\n      // Create COLMETADATA token\n      var metaData = this.getColMetaData();\n      var length = metaData.length;\n\n      // row data\n      var rows = this.rowsData.data;\n      length += rows.length;\n\n      // Create DONE token\n      // It might be nice to make DoneToken a class if anything needs to create them, but for now, just do it here\n      var tBuf = new WritableTrackingBuffer(this.options.tdsVersion < '7_2' ? 9 : 13);\n      tBuf.writeUInt8(TOKEN_TYPE.DONE);\n      var status = DONE_STATUS.FINAL;\n      tBuf.writeUInt16LE(status);\n      tBuf.writeUInt16LE(0); // CurCmd (TDS ignores this)\n      tBuf.writeUInt32LE(0); // row count - doesn't really matter\n      if (this.options.tdsVersion >= '7_2') {\n        tBuf.writeUInt32LE(0); // row count is 64 bits in >= TDS 7.2\n      }\n\n      var done = tBuf.data;\n      length += done.length;\n\n      // composite payload\n      var payload = new WritableTrackingBuffer(length);\n      payload.copyFrom(metaData);\n      payload.copyFrom(rows);\n      payload.copyFrom(done);\n      return payload;\n    }\n  }, {\n    key: 'getColMetaData',\n    value: function getColMetaData() {\n      var tBuf = new WritableTrackingBuffer(100, null, true);\n      // TokenType\n      tBuf.writeUInt8(TOKEN_TYPE.COLMETADATA);\n      // Count\n      tBuf.writeUInt16LE(this.columns.length);\n\n      for (var j = 0, len = this.columns.length; j < len; j++) {\n        var c = this.columns[j];\n        // UserType\n        if (this.options.tdsVersion < '7_2') {\n          tBuf.writeUInt16LE(0);\n        } else {\n          tBuf.writeUInt32LE(0);\n        }\n\n        // Flags\n        var flags = FLAGS.updateableReadWrite;\n        if (c.nullable) {\n          flags |= FLAGS.nullable;\n        } else if (c.nullable === undefined && this.options.tdsVersion >= '7_2') {\n          flags |= FLAGS.nullableUnknown;\n        }\n        tBuf.writeUInt16LE(flags);\n\n        // TYPE_INFO\n        c.type.writeTypeInfo(tBuf, c, this.options);\n\n        // ColName\n        tBuf.writeBVarchar(c.name, 'ucs2');\n      }\n      return tBuf.data;\n    }\n  }]);\n  return BulkLoad;\n}(EventEmitter);","/home/travis/build/npmtest/node-npmtest-tedious/tedious/lib/tracking-buffer/tracking-buffer.js":"'use strict';\n\nmodule.exports.ReadableTrackingBuffer = require('./readable-tracking-buffer');\nmodule.exports.WritableTrackingBuffer = require('./writable-tracking-buffer');","/home/travis/build/npmtest/node-npmtest-tedious/tedious/lib/tracking-buffer/readable-tracking-buffer.js":"'use strict';\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar convertLEBytesToString = require('./bigint').convertLEBytesToString;\n\n/*\n  A Buffer-like class that tracks position.\n\n  As values are read, the position advances by the size of the read data.\n  When reading, if the read would pass the end of the buffer, an error object is thrown.\n */\n\nmodule.exports = function () {\n  function ReadableTrackingBuffer(buffer, encoding) {\n    (0, _classCallCheck3.default)(this, ReadableTrackingBuffer);\n\n    this.buffer = buffer;\n    this.encoding = encoding;\n    if (!this.buffer) {\n      this.buffer = new Buffer(0);\n      this.encoding = undefined;\n    }\n    this.encoding || (this.encoding = 'utf8');\n    this.position = 0;\n  }\n\n  (0, _createClass3.default)(ReadableTrackingBuffer, [{\n    key: 'add',\n    value: function add(buffer) {\n      this.buffer = Buffer.concat([this.buffer.slice(this.position), buffer]);\n      return this.position = 0;\n    }\n  }, {\n    key: 'assertEnoughLeftFor',\n    value: function assertEnoughLeftFor(lengthRequired) {\n      this.previousPosition = this.position;\n      var available = this.buffer.length - this.position;\n      if (available < lengthRequired) {\n        var e = new Error('required : ' + lengthRequired + ', available : ' + available);\n        e.code = 'oob';\n        throw e;\n      }\n    }\n  }, {\n    key: 'empty',\n    value: function empty() {\n      return this.position === this.buffer.length;\n    }\n  }, {\n    key: 'rollback',\n    value: function rollback() {\n      return this.position = this.previousPosition;\n    }\n  }, {\n    key: 'readUInt8',\n    value: function readUInt8() {\n      var length = 1;\n      this.assertEnoughLeftFor(length);\n      this.position += length;\n      return this.buffer.readUInt8(this.position - length);\n    }\n  }, {\n    key: 'readUInt16LE',\n    value: function readUInt16LE() {\n      var length = 2;\n      this.assertEnoughLeftFor(length);\n      this.position += length;\n      return this.buffer.readUInt16LE(this.position - length);\n    }\n  }, {\n    key: 'readUInt16BE',\n    value: function readUInt16BE() {\n      var length = 2;\n      this.assertEnoughLeftFor(length);\n      this.position += length;\n      return this.buffer.readUInt16BE(this.position - length);\n    }\n  }, {\n    key: 'readUInt32LE',\n    value: function readUInt32LE() {\n      var length = 4;\n      this.assertEnoughLeftFor(length);\n      this.position += length;\n      return this.buffer.readUInt32LE(this.position - length);\n    }\n  }, {\n    key: 'readUInt32BE',\n    value: function readUInt32BE() {\n      var length = 4;\n      this.assertEnoughLeftFor(length);\n      this.position += length;\n      return this.buffer.readUInt32BE(this.position - length);\n    }\n  }, {\n    key: 'readInt8',\n    value: function readInt8() {\n      var length = 1;\n      this.assertEnoughLeftFor(length);\n      this.position += length;\n      return this.buffer.readInt8(this.position - length);\n    }\n  }, {\n    key: 'readInt16LE',\n    value: function readInt16LE() {\n      var length = 2;\n      this.assertEnoughLeftFor(length);\n      this.position += length;\n      return this.buffer.readInt16LE(this.position - length);\n    }\n  }, {\n    key: 'readInt16BE',\n    value: function readInt16BE() {\n      var length = 2;\n      this.assertEnoughLeftFor(length);\n      this.position += length;\n      return this.buffer.readInt16BE(this.position - length);\n    }\n  }, {\n    key: 'readInt32LE',\n    value: function readInt32LE() {\n      var length = 4;\n      this.assertEnoughLeftFor(length);\n      this.position += length;\n      return this.buffer.readInt32LE(this.position - length);\n    }\n  }, {\n    key: 'readInt32BE',\n    value: function readInt32BE() {\n      var length = 4;\n      this.assertEnoughLeftFor(length);\n      this.position += length;\n      return this.buffer.readInt32BE(this.position - length);\n    }\n  }, {\n    key: 'readFloatLE',\n    value: function readFloatLE() {\n      var length = 4;\n      this.assertEnoughLeftFor(length);\n      this.position += length;\n      return this.buffer.readFloatLE(this.position - length);\n    }\n  }, {\n    key: 'readDoubleLE',\n    value: function readDoubleLE() {\n      var length = 8;\n      this.assertEnoughLeftFor(length);\n      this.position += length;\n      return this.buffer.readDoubleLE(this.position - length);\n    }\n  }, {\n    key: 'readUInt24LE',\n    value: function readUInt24LE() {\n      var length = 3;\n      this.assertEnoughLeftFor(length);\n      var val = this.buffer[this.position + 1] << 8;\n      val |= this.buffer[this.position];\n      val += this.buffer[this.position + 2] << 16 >>> 0;\n      this.position += length;\n      return val;\n    }\n  }, {\n    key: 'readUInt40LE',\n    value: function readUInt40LE() {\n      var low = this.readBuffer(4).readUInt32LE(0);\n      var high = Buffer.concat([this.readBuffer(1), new Buffer([0x00, 0x00, 0x00])]).readUInt32LE(0);\n      return low + 0x100000000 * high;\n    }\n\n    // If value > 53 bits then it will be incorrect (because Javascript uses IEEE_754 for number representation).\n\n  }, {\n    key: 'readUInt64LE',\n    value: function readUInt64LE() {\n      var low = this.readUInt32LE();\n      var high = this.readUInt32LE();\n      if (high >= 2 << 53 - 32) {\n        console.warn('Read UInt64LE > 53 bits : high=' + high + ', low=' + low);\n      }\n      return low + 0x100000000 * high;\n    }\n  }, {\n    key: 'readUNumeric64LE',\n    value: function readUNumeric64LE() {\n      var low = this.readUInt32LE();\n      var high = this.readUInt32LE();\n      return low + 0x100000000 * high;\n    }\n  }, {\n    key: 'readUNumeric96LE',\n    value: function readUNumeric96LE() {\n      var dword1 = this.readUInt32LE();\n      var dword2 = this.readUInt32LE();\n      var dword3 = this.readUInt32LE();\n      return dword1 + 0x100000000 * dword2 + 0x100000000 * 0x100000000 * dword3;\n    }\n  }, {\n    key: 'readUNumeric128LE',\n    value: function readUNumeric128LE() {\n      var dword1 = this.readUInt32LE();\n      var dword2 = this.readUInt32LE();\n      var dword3 = this.readUInt32LE();\n      var dword4 = this.readUInt32LE();\n      return dword1 + 0x100000000 * dword2 + 0x100000000 * 0x100000000 * dword3 + 0x100000000 * 0x100000000 * 0x100000000 * dword4;\n    }\n  }, {\n    key: 'readString',\n    value: function readString(length, encoding) {\n      encoding || (encoding = this.encoding);\n      this.assertEnoughLeftFor(length);\n      this.position += length;\n      return this.buffer.toString(encoding, this.position - length, this.position);\n    }\n  }, {\n    key: 'readBVarchar',\n    value: function readBVarchar(encoding) {\n      encoding || (encoding = this.encoding);\n      var multiplier = encoding === 'ucs2' ? 2 : 1;\n      var length = this.readUInt8() * multiplier;\n      return this.readString(length, encoding);\n    }\n  }, {\n    key: 'readUsVarchar',\n    value: function readUsVarchar(encoding) {\n      encoding || (encoding = this.encoding);\n      var multiplier = encoding === 'ucs2' ? 2 : 1;\n      var length = this.readUInt16LE() * multiplier;\n      return this.readString(length, encoding);\n    }\n  }, {\n    key: 'readBuffer',\n    value: function readBuffer(length) {\n      this.assertEnoughLeftFor(length);\n      this.position += length;\n      return this.buffer.slice(this.position - length, this.position);\n    }\n  }, {\n    key: 'readArray',\n    value: function readArray(length) {\n      return Array.prototype.slice.call(this.readBuffer(length), 0, length);\n    }\n  }, {\n    key: 'readAsStringBigIntLE',\n    value: function readAsStringBigIntLE(length) {\n      this.assertEnoughLeftFor(length);\n      this.position += length;\n      return convertLEBytesToString(this.buffer.slice(this.position - length, this.position));\n    }\n  }, {\n    key: 'readAsStringInt64LE',\n    value: function readAsStringInt64LE() {\n      return this.readAsStringBigIntLE(8);\n    }\n  }]);\n  return ReadableTrackingBuffer;\n}();","/home/travis/build/npmtest/node-npmtest-tedious/tedious/lib/tracking-buffer/bigint.js":"'use strict';\n\nfunction isZero(array) {\n  for (var j = 0, len = array.length; j < len; j++) {\n    var byte = array[j];\n    if (byte !== 0) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction getNextRemainder(array) {\n  var remainder = 0;\n\n  for (var i = array.length - 1; i >= 0; i--) {\n    var s = remainder * 256 + array[i];\n    array[i] = Math.floor(s / 10);\n    remainder = s % 10;\n  }\n\n  return remainder;\n}\n\nfunction invert(array) {\n  // Invert bits\n  var len = array.length;\n\n  for (var i = 0; i < len; i++) {\n    array[i] = array[i] ^ 0xFF;\n  }\n\n  for (var _i = 0; _i < len; _i++) {\n    array[_i] = array[_i] + 1;\n\n    if (array[_i] > 255) {\n      array[_i] = 0;\n    } else {\n      break;\n    }\n  }\n}\n\nmodule.exports.convertLEBytesToString = convertLEBytesToString;\nfunction convertLEBytesToString(buffer) {\n  var array = Array.prototype.slice.call(buffer, 0, buffer.length);\n  if (isZero(array)) {\n    return '0';\n  } else {\n    var sign = void 0;\n    if (array[array.length - 1] & 0x80) {\n      sign = '-';\n      invert(array);\n    } else {\n      sign = '';\n    }\n    var result = '';\n    while (!isZero(array)) {\n      var t = getNextRemainder(array);\n      result = t + result;\n    }\n    return sign + result;\n  }\n}\n\nmodule.exports.numberToInt64LE = numberToInt64LE;\nfunction numberToInt64LE(num) {\n  // adapted from https://github.com/broofa/node-int64\n  var negate = num < 0;\n  var hi = Math.abs(num);\n  var lo = hi % 0x100000000;\n  hi = hi / 0x100000000 | 0;\n  var buf = new Buffer(8);\n  for (var i = 0; i <= 7; i++) {\n    buf[i] = lo & 0xff;\n    lo = i === 3 ? hi : lo >>> 8;\n  }\n  if (negate) {\n    var carry = 1;\n    for (var _i2 = 0; _i2 <= 7; _i2++) {\n      var v = (buf[_i2] ^ 0xff) + carry;\n      buf[_i2] = v & 0xff;\n      carry = v >> 8;\n    }\n  }\n  return buf;\n}","/home/travis/build/npmtest/node-npmtest-tedious/tedious/lib/tracking-buffer/writable-tracking-buffer.js":"'use strict';\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar bigint = require('./bigint');\n\nvar SHIFT_LEFT_32 = (1 << 16) * (1 << 16);\nvar SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;\nvar UNKNOWN_PLP_LEN = new Buffer([0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff]);\nvar ZERO_LENGTH_BUFFER = new Buffer(0);\n\n/*\n  A Buffer-like class that tracks position.\n\n  As values are written, the position advances by the size of the written data.\n  When writing, automatically allocates new buffers if there's not enough space.\n */\nmodule.exports = function () {\n  function WritableTrackingBuffer(initialSize, encoding, doubleSizeGrowth) {\n    (0, _classCallCheck3.default)(this, WritableTrackingBuffer);\n\n    this.initialSize = initialSize;\n    this.encoding = encoding;\n    this.doubleSizeGrowth = doubleSizeGrowth;\n    this.doubleSizeGrowth || (this.doubleSizeGrowth = false);\n    this.encoding || (this.encoding = 'ucs2');\n    this.buffer = new Buffer(this.initialSize);\n    this.position = 0;\n  }\n\n  (0, _createClass3.default)(WritableTrackingBuffer, [{\n    key: 'copyFrom',\n    value: function copyFrom(buffer) {\n      var length = buffer.length;\n      this.makeRoomFor(length);\n      buffer.copy(this.buffer, this.position);\n      return this.position += length;\n    }\n  }, {\n    key: 'makeRoomFor',\n    value: function makeRoomFor(requiredLength) {\n      if (this.buffer.length - this.position < requiredLength) {\n        if (this.doubleSizeGrowth) {\n          var size = Math.max(128, this.buffer.length * 2);\n          while (size < requiredLength) {\n            size *= 2;\n          }\n          return this.newBuffer(size);\n        } else {\n          return this.newBuffer(requiredLength);\n        }\n      }\n    }\n  }, {\n    key: 'newBuffer',\n    value: function newBuffer(size) {\n      var buffer = this.buffer.slice(0, this.position);\n      if (this.compositeBuffer) {\n        this.compositeBuffer = Buffer.concat([this.compositeBuffer, buffer]);\n      } else {\n        this.compositeBuffer = buffer;\n      }\n      this.buffer = size === 0 ? ZERO_LENGTH_BUFFER : new Buffer(size);\n      return this.position = 0;\n    }\n  }, {\n    key: 'writeUInt8',\n    value: function writeUInt8(value) {\n      var length = 1;\n      this.makeRoomFor(length);\n      this.buffer.writeUInt8(value, this.position);\n      return this.position += length;\n    }\n  }, {\n    key: 'writeUInt16LE',\n    value: function writeUInt16LE(value) {\n      var length = 2;\n      this.makeRoomFor(length);\n      this.buffer.writeUInt16LE(value, this.position);\n      return this.position += length;\n    }\n  }, {\n    key: 'writeUShort',\n    value: function writeUShort(value) {\n      return this.writeUInt16LE(value);\n    }\n  }, {\n    key: 'writeUInt16BE',\n    value: function writeUInt16BE(value) {\n      var length = 2;\n      this.makeRoomFor(length);\n      this.buffer.writeUInt16BE(value, this.position);\n      return this.position += length;\n    }\n  }, {\n    key: 'writeUInt24LE',\n    value: function writeUInt24LE(value) {\n      var length = 3;\n      this.makeRoomFor(length);\n      this.buffer[this.position + 2] = value >>> 16 & 0xff;\n      this.buffer[this.position + 1] = value >>> 8 & 0xff;\n      this.buffer[this.position] = value & 0xff;\n      return this.position += length;\n    }\n  }, {\n    key: 'writeUInt32LE',\n    value: function writeUInt32LE(value) {\n      var length = 4;\n      this.makeRoomFor(length);\n      this.buffer.writeUInt32LE(value, this.position);\n      return this.position += length;\n    }\n  }, {\n    key: 'writeInt64LE',\n    value: function writeInt64LE(value) {\n      var buf = bigint.numberToInt64LE(value);\n      return this.copyFrom(buf);\n    }\n  }, {\n    key: 'writeUInt32BE',\n    value: function writeUInt32BE(value) {\n      var length = 4;\n      this.makeRoomFor(length);\n      this.buffer.writeUInt32BE(value, this.position);\n      return this.position += length;\n    }\n  }, {\n    key: 'writeUInt40LE',\n    value: function writeUInt40LE(value) {\n      // inspired by https://github.com/dpw/node-buffer-more-ints\n      this.writeInt32LE(value & -1);\n      return this.writeUInt8(Math.floor(value * SHIFT_RIGHT_32));\n    }\n  }, {\n    key: 'writeUInt64LE',\n    value: function writeUInt64LE(value) {\n      this.writeInt32LE(value & -1);\n      return this.writeUInt32LE(Math.floor(value * SHIFT_RIGHT_32));\n    }\n  }, {\n    key: 'writeInt8',\n    value: function writeInt8(value) {\n      var length = 1;\n      this.makeRoomFor(length);\n      this.buffer.writeInt8(value, this.position);\n      return this.position += length;\n    }\n  }, {\n    key: 'writeInt16LE',\n    value: function writeInt16LE(value) {\n      var length = 2;\n      this.makeRoomFor(length);\n      this.buffer.writeInt16LE(value, this.position);\n      return this.position += length;\n    }\n  }, {\n    key: 'writeInt16BE',\n    value: function writeInt16BE(value) {\n      var length = 2;\n      this.makeRoomFor(length);\n      this.buffer.writeInt16BE(value, this.position);\n      return this.position += length;\n    }\n  }, {\n    key: 'writeInt32LE',\n    value: function writeInt32LE(value) {\n      var length = 4;\n      this.makeRoomFor(length);\n      this.buffer.writeInt32LE(value, this.position);\n      return this.position += length;\n    }\n  }, {\n    key: 'writeInt32BE',\n    value: function writeInt32BE(value) {\n      var length = 4;\n      this.makeRoomFor(length);\n      this.buffer.writeInt32BE(value, this.position);\n      return this.position += length;\n    }\n  }, {\n    key: 'writeFloatLE',\n    value: function writeFloatLE(value) {\n      var length = 4;\n      this.makeRoomFor(length);\n      this.buffer.writeFloatLE(value, this.position);\n      return this.position += length;\n    }\n  }, {\n    key: 'writeDoubleLE',\n    value: function writeDoubleLE(value) {\n      var length = 8;\n      this.makeRoomFor(length);\n      this.buffer.writeDoubleLE(value, this.position);\n      return this.position += length;\n    }\n  }, {\n    key: 'writeString',\n    value: function writeString(value, encoding) {\n      encoding || (encoding = this.encoding);\n\n      var length = Buffer.byteLength(value, encoding);\n      this.makeRoomFor(length);\n\n      var bytesWritten = this.buffer.write(value, this.position, encoding);\n      this.position += length;\n\n      return bytesWritten;\n    }\n  }, {\n    key: 'writeBVarchar',\n    value: function writeBVarchar(value, encoding) {\n      this.writeUInt8(value.length);\n      return this.writeString(value, encoding);\n    }\n  }, {\n    key: 'writeUsVarchar',\n    value: function writeUsVarchar(value, encoding) {\n      this.writeUInt16LE(value.length);\n      return this.writeString(value, encoding);\n    }\n  }, {\n    key: 'writeUsVarbyte',\n    value: function writeUsVarbyte(value, encoding) {\n      if (encoding == null) {\n        encoding = this.encoding;\n      }\n\n      var length = void 0;\n      if (Buffer.isBuffer(value)) {\n        length = value.length;\n      } else {\n        value = value.toString();\n        length = Buffer.byteLength(value, encoding);\n      }\n      this.writeUInt16LE(length);\n\n      if (Buffer.isBuffer(value)) {\n        return this.writeBuffer(value);\n      } else {\n        this.makeRoomFor(length);\n        this.buffer.write(value, this.position, encoding);\n        return this.position += length;\n      }\n    }\n  }, {\n    key: 'writePLPBody',\n    value: function writePLPBody(value, encoding) {\n      if (encoding == null) {\n        encoding = this.encoding;\n      }\n\n      var length = void 0;\n      if (Buffer.isBuffer(value)) {\n        length = value.length;\n      } else {\n        value = value.toString();\n        length = Buffer.byteLength(value, encoding);\n      }\n\n      // Length of all chunks.\n      // this.writeUInt64LE(length);\n      // unknown seems to work better here - might revisit later.\n      this.writeBuffer(UNKNOWN_PLP_LEN);\n\n      // In the UNKNOWN_PLP_LEN case, the data is represented as a series of zero or more chunks.\n      if (length > 0) {\n        // One chunk.\n        this.writeUInt32LE(length);\n        if (Buffer.isBuffer(value)) {\n          this.writeBuffer(value);\n        } else {\n          this.makeRoomFor(length);\n          this.buffer.write(value, this.position, encoding);\n          this.position += length;\n        }\n      }\n\n      // PLP_TERMINATOR (no more chunks).\n      return this.writeUInt32LE(0);\n    }\n  }, {\n    key: 'writeBuffer',\n    value: function writeBuffer(value) {\n      var length = value.length;\n      this.makeRoomFor(length);\n      value.copy(this.buffer, this.position);\n      return this.position += length;\n    }\n  }, {\n    key: 'writeMoney',\n    value: function writeMoney(value) {\n      this.writeInt32LE(Math.floor(value * SHIFT_RIGHT_32));\n      return this.writeInt32LE(value & -1);\n    }\n  }, {\n    key: 'data',\n    get: function get() {\n      this.newBuffer(0);\n      return this.compositeBuffer;\n    }\n  }]);\n  return WritableTrackingBuffer;\n}();","/home/travis/build/npmtest/node-npmtest-tedious/tedious/lib/token/token.js":"'use strict';\n\nmodule.exports.TYPE = {\n  ALTMETADATA: 0x88,\n  ALTROW: 0xD3,\n  COLMETADATA: 0x81,\n  COLINFO: 0xA5,\n  DONE: 0xFD,\n  DONEPROC: 0xFE,\n  DONEINPROC: 0xFF,\n  ENVCHANGE: 0xE3,\n  ERROR: 0xAA,\n  INFO: 0xAB,\n  LOGINACK: 0xAD,\n  NBCROW: 0xD2,\n  OFFSET: 0x78,\n  ORDER: 0xA9,\n  RETURNSTATUS: 0x79,\n  RETURNVALUE: 0xAC,\n  ROW: 0xD1,\n  SSPI: 0xED,\n  TABNAME: 0xA4\n};","/home/travis/build/npmtest/node-npmtest-tedious/tedious/lib/connection.js":"'use strict';\n\nvar _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = require('babel-runtime/helpers/inherits');\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar BulkLoad = require('./bulk-load');\nvar Debug = require('./debug');\nvar EventEmitter = require('events').EventEmitter;\nvar InstanceLookup = require('./instance-lookup').InstanceLookup;\nvar TYPE = require('./packet').TYPE;\nvar PreloginPayload = require('./prelogin-payload');\nvar Login7Payload = require('./login7-payload');\nvar NTLMResponsePayload = require('./ntlm-payload');\nvar Request = require('./request');\nvar RpcRequestPayload = require('./rpcrequest-payload');\nvar SqlBatchPayload = require('./sqlbatch-payload');\nvar MessageIO = require('./message-io');\nvar TokenStreamParser = require('./token/token-stream-parser').Parser;\nvar Transaction = require('./transaction').Transaction;\nvar ISOLATION_LEVEL = require('./transaction').ISOLATION_LEVEL;\nvar crypto = require('crypto');\nvar ConnectionError = require('./errors').ConnectionError;\nvar RequestError = require('./errors').RequestError;\nvar Connector = require('./connector').Connector;\n\n// A rather basic state machine for managing a connection.\n// Implements something approximating s3.2.1.\n\nvar KEEP_ALIVE_INITIAL_DELAY = 30 * 1000;\nvar DEFAULT_CONNECT_TIMEOUT = 15 * 1000;\nvar DEFAULT_CLIENT_REQUEST_TIMEOUT = 15 * 1000;\nvar DEFAULT_CANCEL_TIMEOUT = 5 * 1000;\nvar DEFAULT_PACKET_SIZE = 4 * 1024;\nvar DEFAULT_TEXTSIZE = '2147483647';\nvar DEFAULT_DATEFIRST = 7;\nvar DEFAULT_PORT = 1433;\nvar DEFAULT_TDS_VERSION = '7_4';\n\nvar Connection = function (_EventEmitter) {\n  (0, _inherits3.default)(Connection, _EventEmitter);\n\n  function Connection(config) {\n    (0, _classCallCheck3.default)(this, Connection);\n\n    var _this = (0, _possibleConstructorReturn3.default)(this, (Connection.__proto__ || (0, _getPrototypeOf2.default)(Connection)).call(this));\n\n    if (!config) {\n      throw new TypeError('No connection configuration given');\n    }\n\n    if (typeof config.server !== 'string') {\n      throw new TypeError('Invalid server: ' + config.server);\n    }\n\n    _this.config = {\n      server: config.server,\n      userName: config.userName,\n      password: config.password,\n      domain: config.domain && config.domain.toUpperCase(),\n      options: {\n        abortTransactionOnError: false,\n        appName: undefined,\n        camelCaseColumns: false,\n        cancelTimeout: DEFAULT_CANCEL_TIMEOUT,\n        columnNameReplacer: undefined,\n        connectTimeout: DEFAULT_CONNECT_TIMEOUT,\n        connectionIsolationLevel: ISOLATION_LEVEL.READ_COMMITTED,\n        cryptoCredentialsDetails: {},\n        database: undefined,\n        datefirst: DEFAULT_DATEFIRST,\n        debug: {\n          data: false,\n          packet: false,\n          payload: false,\n          token: false\n        },\n        enableArithAbort: false,\n        enableAnsiNullDefault: true,\n        encrypt: false,\n        fallbackToDefaultDb: false,\n        instanceName: undefined,\n        isolationLevel: ISOLATION_LEVEL.READ_COMMITTED,\n        localAddress: undefined,\n        multiSubnetFailover: false,\n        packetSize: DEFAULT_PACKET_SIZE,\n        port: DEFAULT_PORT,\n        readOnlyIntent: false,\n        requestTimeout: DEFAULT_CLIENT_REQUEST_TIMEOUT,\n        rowCollectionOnDone: false,\n        rowCollectionOnRequestCompletion: false,\n        tdsVersion: DEFAULT_TDS_VERSION,\n        textsize: DEFAULT_TEXTSIZE,\n        trustServerCertificate: true,\n        useColumnNames: false,\n        useUTC: true\n      }\n    };\n\n    if (config.options) {\n      if (config.options.port && config.options.instanceName) {\n        throw new Error('Port and instanceName are mutually exclusive, but ' + config.options.port + ' and ' + config.options.instanceName + ' provided');\n      }\n\n      if (config.options.abortTransactionOnError != undefined) {\n        _this.config.options.abortTransactionOnError = config.options.abortTransactionOnError;\n      }\n\n      if (config.options.appName != undefined) {\n        _this.config.options.appName = config.options.appName;\n      }\n\n      if (config.options.camelCaseColumns != undefined) {\n        _this.config.options.camelCaseColumns = config.options.camelCaseColumns;\n      }\n\n      if (config.options.cancelTimeout != undefined) {\n        _this.config.options.cancelTimeout = config.options.cancelTimeout;\n      }\n\n      if (config.options.columnNameReplacer) {\n        if (typeof config.options.columnNameReplacer !== 'function') {\n          throw new TypeError('options.columnNameReplacer must be a function or null.');\n        }\n\n        _this.config.options.columnNameReplacer = config.options.columnNameReplacer;\n      }\n\n      if (config.options.connectTimeout) {\n        _this.config.options.connectTimeout = config.options.connectTimeout;\n      }\n\n      if (config.options.connectionIsolationLevel) {\n        _this.config.options.connectionIsolationLevel = config.options.connectionIsolationLevel;\n      }\n\n      if (config.options.cryptoCredentialsDetails) {\n        _this.config.options.cryptoCredentialsDetails = config.options.cryptoCredentialsDetails;\n      }\n\n      if (config.options.database != undefined) {\n        _this.config.options.database = config.options.database;\n      }\n\n      if (config.options.datefirst) {\n        if (config.options.datefirst < 1 || config.options.datefirst > 7) {\n          throw new RangeError('DateFirst should be >= 1 and <= 7');\n        }\n\n        _this.config.options.datefirst = config.options.datefirst;\n      }\n\n      if (config.options.debug) {\n        if (config.options.debug.data != undefined) {\n          _this.config.options.debug.data = config.options.debug.data;\n        }\n        if (config.options.debug.packet != undefined) {\n          _this.config.options.debug.packet = config.options.debug.packet;\n        }\n        if (config.options.debug.payload != undefined) {\n          _this.config.options.debug.payload = config.options.debug.payload;\n        }\n        if (config.options.debug.token != undefined) {\n          _this.config.options.debug.token = config.options.debug.token;\n        }\n      }\n\n      if (config.options.enableAnsiNullDefault != undefined) {\n        _this.config.options.enableAnsiNullDefault = config.options.enableAnsiNullDefault;\n      }\n\n      if (config.options.enableArithAbort !== undefined) {\n        if (typeof config.options.enableArithAbort !== 'boolean') {\n          throw new TypeError('options.enableArithAbort must be a boolean (true or false).');\n        }\n\n        _this.config.options.enableArithAbort = config.options.enableArithAbort;\n      }\n\n      if (config.options.encrypt != undefined) {\n        _this.config.options.encrypt = config.options.encrypt;\n      }\n\n      if (config.options.fallbackToDefaultDb != undefined) {\n        _this.config.options.fallbackToDefaultDb = config.options.fallbackToDefaultDb;\n      }\n\n      if (config.options.instanceName != undefined) {\n        _this.config.options.instanceName = config.options.instanceName;\n        _this.config.options.port = undefined;\n      }\n\n      if (config.options.isolationLevel) {\n        _this.config.options.isolationLevel = config.options.isolationLevel;\n      }\n\n      if (config.options.localAddress != undefined) {\n        _this.config.options.localAddress = config.options.localAddress;\n      }\n\n      if (config.options.multiSubnetFailover != undefined) {\n        _this.config.options.multiSubnetFailover = !!config.options.multiSubnetFailover;\n      }\n\n      if (config.options.packetSize) {\n        _this.config.options.packetSize = config.options.packetSize;\n      }\n\n      if (config.options.port) {\n        if (config.options.port < 0 || config.options.port > 65536) {\n          throw new RangeError('Port should be > 0 and < 65536');\n        }\n\n        _this.config.options.port = config.options.port;\n        _this.config.options.instanceName = undefined;\n      }\n\n      if (config.options.readOnlyIntent != undefined) {\n        _this.config.options.readOnlyIntent = config.options.readOnlyIntent;\n      }\n\n      if (config.options.requestTimeout != undefined) {\n        _this.config.options.requestTimeout = config.options.requestTimeout;\n      }\n\n      if (config.options.rowCollectionOnDone != undefined) {\n        _this.config.options.rowCollectionOnDone = config.options.rowCollectionOnDone;\n      }\n\n      if (config.options.rowCollectionOnRequestCompletion != undefined) {\n        _this.config.options.rowCollectionOnRequestCompletion = config.options.rowCollectionOnRequestCompletion;\n      }\n\n      if (config.options.tdsVersion) {\n        _this.config.options.tdsVersion = config.options.tdsVersion;\n      }\n\n      if (config.options.textsize) {\n        _this.config.options.textsize = config.options.textsize;\n      }\n\n      if (config.options.trustServerCertificate != undefined) {\n        _this.config.options.trustServerCertificate = config.options.trustServerCertificate;\n      }\n\n      if (config.options.useColumnNames != undefined) {\n        _this.config.options.useColumnNames = config.options.useColumnNames;\n      }\n\n      if (config.options.useUTC != undefined) {\n        _this.config.options.useUTC = config.options.useUTC;\n      }\n    }\n\n    _this.reset = _this.reset.bind(_this);\n    _this.socketClose = _this.socketClose.bind(_this);\n    _this.socketEnd = _this.socketEnd.bind(_this);\n    _this.socketConnect = _this.socketConnect.bind(_this);\n    _this.socketError = _this.socketError.bind(_this);\n    _this.requestTimeout = _this.requestTimeout.bind(_this);\n    _this.connectTimeout = _this.connectTimeout.bind(_this);\n    _this.createDebug();\n    _this.createTokenStreamParser();\n    _this.inTransaction = false;\n    _this.transactionDescriptors = [new Buffer([0, 0, 0, 0, 0, 0, 0, 0])];\n    _this.transitionTo(_this.STATE.CONNECTING);\n\n    if (_this.config.options.tdsVersion < '7_2') {\n      // 'beginTransaction', 'commitTransaction' and 'rollbackTransaction'\n      // events are utilized to maintain inTransaction property state which in\n      // turn is used in managing transactions. These events are only fired for\n      // TDS version 7.2 and beyond. The properties below are used to emulate\n      // equivalent behavior for TDS versions before 7.2.\n      _this.transactionDepth = 0;\n      _this.isSqlBatch = false;\n    }\n    return _this;\n  }\n\n  (0, _createClass3.default)(Connection, [{\n    key: 'close',\n    value: function close() {\n      return this.transitionTo(this.STATE.FINAL);\n    }\n  }, {\n    key: 'initialiseConnection',\n    value: function initialiseConnection() {\n      this.connect();\n      return this.createConnectTimer();\n    }\n  }, {\n    key: 'cleanupConnection',\n    value: function cleanupConnection(redirect) {\n      this.redirect = redirect;\n      if (!this.closed) {\n        this.clearConnectTimer();\n        this.clearRequestTimer();\n        this.closeConnection();\n        if (!this.redirect) {\n          this.emit('end');\n        } else {\n          this.emit('rerouting');\n        }\n        if (this.request) {\n          var err = RequestError('Connection closed before request completed.', 'ECLOSE');\n          this.request.callback(err);\n          this.request = undefined;\n        }\n        this.closed = true;\n        this.loggedIn = false;\n        return this.loginError = null;\n      }\n    }\n  }, {\n    key: 'createDebug',\n    value: function createDebug() {\n      var _this2 = this;\n\n      this.debug = new Debug(this.config.options.debug);\n      return this.debug.on('debug', function (message) {\n        return _this2.emit('debug', message);\n      });\n    }\n  }, {\n    key: 'createTokenStreamParser',\n    value: function createTokenStreamParser() {\n      var _this3 = this;\n\n      this.tokenStreamParser = new TokenStreamParser(this.debug, undefined, this.config.options);\n\n      this.tokenStreamParser.on('infoMessage', function (token) {\n        return _this3.emit('infoMessage', token);\n      });\n\n      this.tokenStreamParser.on('sspichallenge', function (token) {\n        if (token.ntlmpacket) {\n          _this3.ntlmpacket = token.ntlmpacket;\n        }\n        return _this3.emit('sspichallenge', token);\n      });\n\n      this.tokenStreamParser.on('errorMessage', function (token) {\n        _this3.emit('errorMessage', token);\n        if (_this3.loggedIn) {\n          if (_this3.request) {\n            _this3.request.error = RequestError(token.message, 'EREQUEST');\n            _this3.request.error.number = token.number;\n            _this3.request.error.state = token.state;\n            _this3.request.error['class'] = token['class'];\n            _this3.request.error.serverName = token.serverName;\n            _this3.request.error.procName = token.procName;\n            return _this3.request.error.lineNumber = token.lineNumber;\n          }\n        } else {\n          return _this3.loginError = ConnectionError(token.message, 'ELOGIN');\n        }\n      });\n\n      this.tokenStreamParser.on('databaseChange', function (token) {\n        return _this3.emit('databaseChange', token.newValue);\n      });\n\n      this.tokenStreamParser.on('languageChange', function (token) {\n        return _this3.emit('languageChange', token.newValue);\n      });\n\n      this.tokenStreamParser.on('charsetChange', function (token) {\n        return _this3.emit('charsetChange', token.newValue);\n      });\n\n      this.tokenStreamParser.on('loginack', function (token) {\n        if (!token.tdsVersion) {\n          // unsupported TDS version\n          _this3.loginError = ConnectionError('Server responded with unknown TDS version.', 'ETDS');\n          _this3.loggedIn = false;\n          return;\n        }\n\n        if (!token['interface']) {\n          // unsupported interface\n          _this3.loginError = ConnectionError('Server responded with unsupported interface.', 'EINTERFACENOTSUPP');\n          _this3.loggedIn = false;\n          return;\n        }\n\n        // use negotiated version\n        _this3.config.options.tdsVersion = token.tdsVersion;\n        return _this3.loggedIn = true;\n      });\n\n      this.tokenStreamParser.on('routingChange', function (token) {\n        _this3.routingData = token.newValue;\n        return _this3.dispatchEvent('routingChange');\n      });\n\n      this.tokenStreamParser.on('packetSizeChange', function (token) {\n        return _this3.messageIo.packetSize(token.newValue);\n      });\n\n      // A new top-level transaction was started. This is not fired\n      // for nested transactions.\n      this.tokenStreamParser.on('beginTransaction', function (token) {\n        _this3.transactionDescriptors.push(token.newValue);\n        return _this3.inTransaction = true;\n      });\n\n      // A top-level transaction was committed. This is not fired\n      // for nested transactions.\n      this.tokenStreamParser.on('commitTransaction', function () {\n        _this3.transactionDescriptors.length = 1;\n        return _this3.inTransaction = false;\n      });\n\n      // A top-level transaction was rolled back. This is not fired\n      // for nested transactions. This is also fired if a batch\n      // aborting error happened that caused a rollback.\n      this.tokenStreamParser.on('rollbackTransaction', function () {\n        _this3.transactionDescriptors.length = 1;\n        // An outermost transaction was rolled back. Reset the transaction counter\n        _this3.inTransaction = false;\n        return _this3.emit('rollbackTransaction');\n      });\n\n      this.tokenStreamParser.on('columnMetadata', function (token) {\n        if (_this3.request) {\n          var columns = void 0;\n          if (_this3.config.options.useColumnNames) {\n            columns = {};\n            for (var j = 0, len = token.columns.length; j < len; j++) {\n              var col = token.columns[j];\n              if (columns[col.colName] == null) {\n                columns[col.colName] = col;\n              }\n            }\n          } else {\n            columns = token.columns;\n          }\n          return _this3.request.emit('columnMetadata', columns);\n        } else {\n          _this3.emit('error', new Error(\"Received 'columnMetadata' when no sqlRequest is in progress\"));\n          return _this3.close();\n        }\n      });\n\n      this.tokenStreamParser.on('order', function (token) {\n        if (_this3.request) {\n          return _this3.request.emit('order', token.orderColumns);\n        } else {\n          _this3.emit('error', new Error(\"Received 'order' when no sqlRequest is in progress\"));\n          return _this3.close();\n        }\n      });\n\n      this.tokenStreamParser.on('row', function (token) {\n        if (_this3.request) {\n          if (_this3.config.options.rowCollectionOnRequestCompletion) {\n            _this3.request.rows.push(token.columns);\n          }\n          if (_this3.config.options.rowCollectionOnDone) {\n            _this3.request.rst.push(token.columns);\n          }\n          return _this3.request.emit('row', token.columns);\n        } else {\n          _this3.emit('error', new Error(\"Received 'row' when no sqlRequest is in progress\"));\n          return _this3.close();\n        }\n      });\n\n      this.tokenStreamParser.on('returnStatus', function (token) {\n        if (_this3.request) {\n          // Keep value for passing in 'doneProc' event.\n          return _this3.procReturnStatusValue = token.value;\n        }\n      });\n\n      this.tokenStreamParser.on('returnValue', function (token) {\n        if (_this3.request) {\n          return _this3.request.emit('returnValue', token.paramName, token.value, token.metadata);\n        }\n      });\n\n      this.tokenStreamParser.on('doneProc', function (token) {\n        if (_this3.request) {\n          _this3.request.emit('doneProc', token.rowCount, token.more, _this3.procReturnStatusValue, _this3.request.rst);\n          _this3.procReturnStatusValue = undefined;\n          if (token.rowCount !== undefined) {\n            _this3.request.rowCount += token.rowCount;\n          }\n          if (_this3.config.options.rowCollectionOnDone) {\n            return _this3.request.rst = [];\n          }\n        }\n      });\n\n      this.tokenStreamParser.on('doneInProc', function (token) {\n        if (_this3.request) {\n          _this3.request.emit('doneInProc', token.rowCount, token.more, _this3.request.rst);\n          if (token.rowCount !== undefined) {\n            _this3.request.rowCount += token.rowCount;\n          }\n          if (_this3.config.options.rowCollectionOnDone) {\n            return _this3.request.rst = [];\n          }\n        }\n      });\n\n      this.tokenStreamParser.on('done', function (token) {\n        if (_this3.request) {\n          if (token.attention) {\n            _this3.dispatchEvent('attention');\n          }\n          if (token.sqlError && !_this3.request.error) {\n            // check if the DONE_ERROR flags was set, but an ERROR token was not sent.\n            _this3.request.error = RequestError('An unknown error has occurred.', 'UNKNOWN');\n          }\n          _this3.request.emit('done', token.rowCount, token.more, _this3.request.rst);\n          if (token.rowCount !== undefined) {\n            _this3.request.rowCount += token.rowCount;\n          }\n          if (_this3.config.options.rowCollectionOnDone) {\n            return _this3.request.rst = [];\n          }\n        }\n      });\n\n      this.tokenStreamParser.on('resetConnection', function () {\n        return _this3.emit('resetConnection');\n      });\n\n      this.tokenStreamParser.on('tokenStreamError', function (error) {\n        _this3.emit('error', error);\n        return _this3.close();\n      });\n    }\n  }, {\n    key: 'connect',\n    value: function connect() {\n      var _this4 = this;\n\n      if (this.config.options.port) {\n        return this.connectOnPort(this.config.options.port, this.config.options.multiSubnetFailover);\n      } else {\n        return new InstanceLookup().instanceLookup({\n          server: this.config.server,\n          instanceName: this.config.options.instanceName,\n          timeout: this.config.options.connectTimeout\n        }, function (message, port) {\n          if (_this4.state === _this4.STATE.FINAL) {\n            return;\n          }\n          if (message) {\n            return _this4.emit('connect', ConnectionError(message, 'EINSTLOOKUP'));\n          } else {\n            return _this4.connectOnPort(port, _this4.config.options.multiSubnetFailover);\n          }\n        });\n      }\n    }\n  }, {\n    key: 'connectOnPort',\n    value: function connectOnPort(port, multiSubnetFailover) {\n      var _this5 = this;\n\n      var connectOpts = {\n        host: this.routingData ? this.routingData.server : this.config.server,\n        port: this.routingData ? this.routingData.port : port,\n        localAddress: this.config.options.localAddress\n      };\n\n      new Connector(connectOpts, multiSubnetFailover).execute(function (err, socket) {\n        if (err) {\n          return _this5.socketError(err);\n        }\n\n        _this5.socket = socket;\n        _this5.socket.on('error', _this5.socketError);\n        _this5.socket.on('close', _this5.socketClose);\n        _this5.socket.on('end', _this5.socketEnd);\n        _this5.messageIo = new MessageIO(_this5.socket, _this5.config.options.packetSize, _this5.debug);\n        _this5.messageIo.on('data', function (data) {\n          _this5.dispatchEvent('data', data);\n        });\n        _this5.messageIo.on('message', function () {\n          _this5.dispatchEvent('message');\n        });\n        _this5.messageIo.on('secure', _this5.emit.bind(_this5, 'secure'));\n\n        _this5.socketConnect();\n      });\n    }\n  }, {\n    key: 'closeConnection',\n    value: function closeConnection() {\n      if (this.socket) {\n        this.socket.destroy();\n      }\n    }\n  }, {\n    key: 'createConnectTimer',\n    value: function createConnectTimer() {\n      return this.connectTimer = setTimeout(this.connectTimeout, this.config.options.connectTimeout);\n    }\n  }, {\n    key: 'createRequestTimer',\n    value: function createRequestTimer() {\n      this.clearRequestTimer(); // release old timer, just to be safe\n      if (this.config.options.requestTimeout) {\n        return this.requestTimer = setTimeout(this.requestTimeout, this.config.options.requestTimeout);\n      }\n    }\n  }, {\n    key: 'connectTimeout',\n    value: function connectTimeout() {\n      var message = 'Failed to connect to ' + this.config.server + ':' + this.config.options.port + ' in ' + this.config.options.connectTimeout + 'ms';\n      this.debug.log(message);\n      this.emit('connect', ConnectionError(message, 'ETIMEOUT'));\n      this.connectTimer = undefined;\n      return this.dispatchEvent('connectTimeout');\n    }\n  }, {\n    key: 'requestTimeout',\n    value: function requestTimeout() {\n      this.requestTimer = undefined;\n      this.messageIo.sendMessage(TYPE.ATTENTION);\n      return this.transitionTo(this.STATE.SENT_ATTENTION);\n    }\n  }, {\n    key: 'clearConnectTimer',\n    value: function clearConnectTimer() {\n      if (this.connectTimer) {\n        return clearTimeout(this.connectTimer);\n      }\n    }\n  }, {\n    key: 'clearRequestTimer',\n    value: function clearRequestTimer() {\n      if (this.requestTimer) {\n        clearTimeout(this.requestTimer);\n        this.requestTimer = undefined;\n      }\n    }\n  }, {\n    key: 'transitionTo',\n    value: function transitionTo(newState) {\n      if (this.state === newState) {\n        this.debug.log('State is already ' + newState.name);\n        return;\n      }\n\n      if (this.state && this.state.exit) {\n        this.state.exit.apply(this);\n      }\n\n      this.debug.log('State change: ' + (this.state ? this.state.name : undefined) + ' -> ' + newState.name);\n      this.state = newState;\n\n      if (this.state.enter) {\n        return this.state.enter.apply(this);\n      }\n    }\n  }, {\n    key: 'dispatchEvent',\n    value: function dispatchEvent(eventName) {\n      if (this.state.events[eventName]) {\n        var args = new Array(arguments.length - 1);\n        for (var i = 0; i < args.length;) {\n          args[i++] = arguments[i];\n        }\n        return this.state.events[eventName].apply(this, args);\n      } else {\n        this.emit('error', new Error(`No event '${eventName}' in state '${this.state.name}'`));\n        return this.close();\n      }\n    }\n  }, {\n    key: 'socketError',\n    value: function socketError(error) {\n      if (this.state === this.STATE.CONNECTING) {\n        var message = `Failed to connect to ${this.config.server}:${this.config.options.port} - ${error.message}`;\n        this.debug.log(message);\n        this.emit('connect', ConnectionError(message, 'ESOCKET'));\n      } else {\n        var _message = `Connection lost - ${error.message}`;\n        this.debug.log(_message);\n        this.emit('error', ConnectionError(_message, 'ESOCKET'));\n      }\n      return this.dispatchEvent('socketError', error);\n    }\n  }, {\n    key: 'socketConnect',\n    value: function socketConnect() {\n      this.socket.setKeepAlive(true, KEEP_ALIVE_INITIAL_DELAY);\n      this.closed = false;\n      this.debug.log('connected to ' + this.config.server + ':' + this.config.options.port);\n      return this.dispatchEvent('socketConnect');\n    }\n  }, {\n    key: 'socketEnd',\n    value: function socketEnd() {\n      this.debug.log('socket ended');\n      return this.transitionTo(this.STATE.FINAL);\n    }\n  }, {\n    key: 'socketClose',\n    value: function socketClose() {\n      this.debug.log('connection to ' + this.config.server + ':' + this.config.options.port + ' closed');\n      if (this.state === this.STATE.REROUTING) {\n        this.debug.log('Rerouting to ' + this.routingData.server + ':' + this.routingData.port);\n        return this.dispatchEvent('reconnect');\n      } else {\n        return this.transitionTo(this.STATE.FINAL);\n      }\n    }\n  }, {\n    key: 'sendPreLogin',\n    value: function sendPreLogin() {\n      var payload = new PreloginPayload({\n        encrypt: this.config.options.encrypt\n      });\n      this.messageIo.sendMessage(TYPE.PRELOGIN, payload.data);\n      return this.debug.payload(function () {\n        return payload.toString('  ');\n      });\n    }\n  }, {\n    key: 'emptyMessageBuffer',\n    value: function emptyMessageBuffer() {\n      return this.messageBuffer = new Buffer(0);\n    }\n  }, {\n    key: 'addToMessageBuffer',\n    value: function addToMessageBuffer(data) {\n      return this.messageBuffer = Buffer.concat([this.messageBuffer, data]);\n    }\n  }, {\n    key: 'processPreLoginResponse',\n    value: function processPreLoginResponse() {\n      var preloginPayload = new PreloginPayload(this.messageBuffer);\n      this.debug.payload(function () {\n        return preloginPayload.toString('  ');\n      });\n\n      if (preloginPayload.encryptionString === 'ON' || preloginPayload.encryptionString === 'REQ') {\n        if (!this.config.options.encrypt) {\n          this.emit('connect', ConnectionError(\"Server requires encryption, set 'encrypt' config option to true.\", 'EENCRYPT'));\n          return this.close();\n        }\n\n        return this.dispatchEvent('tls');\n      } else {\n        return this.dispatchEvent('noTls');\n      }\n    }\n  }, {\n    key: 'sendLogin7Packet',\n    value: function sendLogin7Packet() {\n      var payload = new Login7Payload({\n        domain: this.config.domain,\n        userName: this.config.userName,\n        password: this.config.password,\n        database: this.config.options.database,\n        serverName: this.routingData ? this.routingData.server : this.config.server,\n        appName: this.config.options.appName,\n        packetSize: this.config.options.packetSize,\n        tdsVersion: this.config.options.tdsVersion,\n        initDbFatal: !this.config.options.fallbackToDefaultDb,\n        readOnlyIntent: this.config.options.readOnlyIntent\n      });\n\n      this.routingData = undefined;\n      this.messageIo.sendMessage(TYPE.LOGIN7, payload.data);\n\n      return this.debug.payload(function () {\n        return payload.toString('  ');\n      });\n    }\n  }, {\n    key: 'sendNTLMResponsePacket',\n    value: function sendNTLMResponsePacket() {\n      var payload = new NTLMResponsePayload({\n        domain: this.config.domain,\n        userName: this.config.userName,\n        password: this.config.password,\n        database: this.config.options.database,\n        appName: this.config.options.appName,\n        packetSize: this.config.options.packetSize,\n        tdsVersion: this.config.options.tdsVersion,\n        ntlmpacket: this.ntlmpacket,\n        additional: this.additional\n      });\n      this.messageIo.sendMessage(TYPE.NTLMAUTH_PKT, payload.data);\n      return this.debug.payload(function () {\n        return payload.toString('  ');\n      });\n    }\n  }, {\n    key: 'sendDataToTokenStreamParser',\n    value: function sendDataToTokenStreamParser(data) {\n      return this.tokenStreamParser.addBuffer(data);\n    }\n  }, {\n    key: 'sendInitialSql',\n    value: function sendInitialSql() {\n      var payload = new SqlBatchPayload(this.getInitialSql(), this.currentTransactionDescriptor(), this.config.options);\n      return this.messageIo.sendMessage(TYPE.SQL_BATCH, payload.data);\n    }\n  }, {\n    key: 'getInitialSql',\n    value: function getInitialSql() {\n      var xact_abort = this.config.options.abortTransactionOnError ? 'on' : 'off';\n      var enableAnsiNullDefault = this.config.options.enableAnsiNullDefault ? 'on' : 'off';\n      var enableArithAbort = this.config.options.enableArithAbort ? 'on' : 'off';\n      return 'set textsize ' + this.config.options.textsize + '\\nset quoted_identifier on\\nset arithabort ' + enableArithAbort + '\\nset numeric_roundabort off\\nset ansi_warnings on\\nset ansi_padding on\\nset ansi_nulls on\\nset ansi_null_dflt_on ' + enableAnsiNullDefault + '\\nset concat_null_yields_null on\\nset cursor_close_on_commit off\\nset implicit_transactions off\\nset language us_english\\nset dateformat mdy\\nset datefirst ' + this.config.options.datefirst + '\\nset transaction isolation level ' + this.getIsolationLevelText(this.config.options.connectionIsolationLevel) + '\\nset xact_abort ' + xact_abort;\n    }\n  }, {\n    key: 'processedInitialSql',\n    value: function processedInitialSql() {\n      this.clearConnectTimer();\n      return this.emit('connect');\n    }\n  }, {\n    key: 'processLogin7Response',\n    value: function processLogin7Response() {\n      if (this.loggedIn) {\n        return this.dispatchEvent('loggedIn');\n      } else {\n        if (this.loginError) {\n          this.emit('connect', this.loginError);\n        } else {\n          this.emit('connect', ConnectionError('Login failed.', 'ELOGIN'));\n        }\n        return this.dispatchEvent('loginFailed');\n      }\n    }\n  }, {\n    key: 'processLogin7NTLMResponse',\n    value: function processLogin7NTLMResponse() {\n      if (this.ntlmpacket) {\n        return this.dispatchEvent('receivedChallenge');\n      } else {\n        if (this.loginError) {\n          this.emit('connect', this.loginError);\n        } else {\n          this.emit('connect', ConnectionError('Login failed.', 'ELOGIN'));\n        }\n        return this.dispatchEvent('loginFailed');\n      }\n    }\n  }, {\n    key: 'processLogin7NTLMAck',\n    value: function processLogin7NTLMAck() {\n      if (this.loggedIn) {\n        return this.dispatchEvent('loggedIn');\n      } else {\n        if (this.loginError) {\n          this.emit('connect', this.loginError);\n        } else {\n          this.emit('connect', ConnectionError('Login failed.', 'ELOGIN'));\n        }\n        return this.dispatchEvent('loginFailed');\n      }\n    }\n  }, {\n    key: 'execSqlBatch',\n    value: function execSqlBatch(request) {\n      return this.makeRequest(request, TYPE.SQL_BATCH, new SqlBatchPayload(request.sqlTextOrProcedure, this.currentTransactionDescriptor(), this.config.options));\n    }\n  }, {\n    key: 'execSql',\n    value: function execSql(request) {\n      var _this6 = this;\n\n      request.transformIntoExecuteSqlRpc();\n      if (request.error != null) {\n        return process.nextTick(function () {\n          _this6.debug.log(request.error.message);\n          return request.callback(request.error);\n        });\n      }\n      return this.makeRequest(request, TYPE.RPC_REQUEST, new RpcRequestPayload(request, this.currentTransactionDescriptor(), this.config.options));\n    }\n  }, {\n    key: 'newBulkLoad',\n    value: function newBulkLoad(table, callback) {\n      return new BulkLoad(table, this.config.options, callback);\n    }\n  }, {\n    key: 'execBulkLoad',\n    value: function execBulkLoad(bulkLoad) {\n      var _this7 = this;\n\n      var request = new Request(bulkLoad.getBulkInsertSql(), function (error) {\n        if (error) {\n          if (error.code === 'UNKNOWN') {\n            error.message += ' This is likely because the schema of the BulkLoad does not match the schema of the table you are attempting to insert into.';\n          }\n          bulkLoad.error = error;\n          return bulkLoad.callback(error);\n        } else {\n          return _this7.makeRequest(bulkLoad, TYPE.BULK_LOAD, bulkLoad.getPayload());\n        }\n      });\n      return this.execSqlBatch(request);\n    }\n  }, {\n    key: 'prepare',\n    value: function prepare(request) {\n      request.transformIntoPrepareRpc();\n      return this.makeRequest(request, TYPE.RPC_REQUEST, new RpcRequestPayload(request, this.currentTransactionDescriptor(), this.config.options));\n    }\n  }, {\n    key: 'unprepare',\n    value: function unprepare(request) {\n      request.transformIntoUnprepareRpc();\n      return this.makeRequest(request, TYPE.RPC_REQUEST, new RpcRequestPayload(request, this.currentTransactionDescriptor(), this.config.options));\n    }\n  }, {\n    key: 'execute',\n    value: function execute(request, parameters) {\n      var _this8 = this;\n\n      request.transformIntoExecuteRpc(parameters);\n      if (request.error != null) {\n        return process.nextTick(function () {\n          _this8.debug.log(request.error.message);\n          return request.callback(request.error);\n        });\n      }\n      return this.makeRequest(request, TYPE.RPC_REQUEST, new RpcRequestPayload(request, this.currentTransactionDescriptor(), this.config.options));\n    }\n  }, {\n    key: 'callProcedure',\n    value: function callProcedure(request) {\n      var _this9 = this;\n\n      request.validateParameters();\n      if (request.error != null) {\n        return process.nextTick(function () {\n          _this9.debug.log(request.error.message);\n          return request.callback(request.error);\n        });\n      }\n      return this.makeRequest(request, TYPE.RPC_REQUEST, new RpcRequestPayload(request, this.currentTransactionDescriptor(), this.config.options));\n    }\n  }, {\n    key: 'beginTransaction',\n    value: function beginTransaction(callback, name, isolationLevel) {\n      var _this10 = this;\n\n      isolationLevel || (isolationLevel = this.config.options.isolationLevel);\n      var transaction = new Transaction(name || '', isolationLevel);\n      if (this.config.options.tdsVersion < '7_2') {\n        var self = this;\n        return this.execSqlBatch(new Request('SET TRANSACTION ISOLATION LEVEL ' + transaction.isolationLevelToTSQL() + ';BEGIN TRAN ' + transaction.name, function () {\n          self.transactionDepth++;\n          if (self.transactionDepth === 1) {\n            self.inTransaction = true;\n          }\n          return callback.apply(null, arguments);\n        }));\n      }\n\n      var request = new Request(undefined, function (err) {\n        return callback(err, _this10.currentTransactionDescriptor());\n      });\n      return this.makeRequest(request, TYPE.TRANSACTION_MANAGER, transaction.beginPayload(this.currentTransactionDescriptor()));\n    }\n  }, {\n    key: 'commitTransaction',\n    value: function commitTransaction(callback, name) {\n      var transaction = new Transaction(name || '');\n      if (this.config.options.tdsVersion < '7_2') {\n        var self = this;\n        return this.execSqlBatch(new Request('COMMIT TRAN ' + transaction.name, function () {\n          self.transactionDepth--;\n          if (self.transactionDepth === 0) {\n            self.inTransaction = false;\n          }\n          return callback.apply(null, arguments);\n        }));\n      }\n      var request = new Request(undefined, callback);\n      return this.makeRequest(request, TYPE.TRANSACTION_MANAGER, transaction.commitPayload(this.currentTransactionDescriptor()));\n    }\n  }, {\n    key: 'rollbackTransaction',\n    value: function rollbackTransaction(callback, name) {\n      var transaction = new Transaction(name || '');\n      if (this.config.options.tdsVersion < '7_2') {\n        var self = this;\n        return this.execSqlBatch(new Request('ROLLBACK TRAN ' + transaction.name, function () {\n          self.transactionDepth--;\n          if (self.transactionDepth === 0) {\n            self.inTransaction = false;\n          }\n          return callback.apply(null, arguments);\n        }));\n      }\n      var request = new Request(undefined, callback);\n      return this.makeRequest(request, TYPE.TRANSACTION_MANAGER, transaction.rollbackPayload(this.currentTransactionDescriptor()));\n    }\n  }, {\n    key: 'saveTransaction',\n    value: function saveTransaction(callback, name) {\n      var transaction = new Transaction(name);\n      if (this.config.options.tdsVersion < '7_2') {\n        var self = this;\n        return this.execSqlBatch(new Request('SAVE TRAN ' + transaction.name, function () {\n          self.transactionDepth++;\n          return callback.apply(null, arguments);\n        }));\n      }\n      var request = new Request(undefined, callback);\n      return this.makeRequest(request, TYPE.TRANSACTION_MANAGER, transaction.savePayload(this.currentTransactionDescriptor()));\n    }\n  }, {\n    key: 'transaction',\n    value: function transaction(cb, isolationLevel) {\n      var _this11 = this;\n\n      if (typeof cb !== 'function') {\n        throw new TypeError('`cb` must be a function');\n      }\n      var useSavepoint = this.inTransaction;\n      var name = '_tedious_' + crypto.randomBytes(10).toString('hex');\n      var self = this;\n      var txDone = function txDone(err, done) {\n        var args = new Array(arguments.length - 2);\n        for (var i = 0; i < args.length;) {\n          args[i++] = arguments[i + 1];\n        }\n\n        if (err) {\n          if (self.inTransaction && self.state === self.STATE.LOGGED_IN) {\n            return self.rollbackTransaction(function (txErr) {\n              args.unshift(txErr || err);\n              return done.apply(null, args);\n            }, name);\n          } else {\n            return process.nextTick(function () {\n              args.unshift(err);\n              return done.apply(null, args);\n            });\n          }\n        } else {\n          if (useSavepoint) {\n            return process.nextTick(function () {\n              if (self.config.options.tdsVersion < '7_2') {\n                self.transactionDepth--;\n              }\n              args.unshift(null);\n              return done.apply(null, args);\n            });\n          } else {\n            return self.commitTransaction(function (txErr) {\n              args.unshift(txErr);\n              return done.apply(null, args);\n            }, name);\n          }\n        }\n      };\n      if (useSavepoint) {\n        return this.saveTransaction(function (err) {\n          if (err) {\n            return cb(err);\n          }\n          if (isolationLevel) {\n            return _this11.execSqlBatch(new Request('SET transaction isolation level ' + _this11.getIsolationLevelText(isolationLevel), function (err) {\n              return cb(err, txDone);\n            }));\n          } else {\n            return cb(null, txDone);\n          }\n        }, name);\n      } else {\n        return this.beginTransaction(function (err) {\n          if (err) {\n            return cb(err);\n          }\n          return cb(null, txDone);\n        }, name, isolationLevel);\n      }\n    }\n  }, {\n    key: 'makeRequest',\n    value: function makeRequest(request, packetType, payload) {\n      if (this.state !== this.STATE.LOGGED_IN) {\n        var message = 'Requests can only be made in the ' + this.STATE.LOGGED_IN.name + ' state, not the ' + this.state.name + ' state';\n        this.debug.log(message);\n        return request.callback(RequestError(message, 'EINVALIDSTATE'));\n      } else {\n        if (packetType === TYPE.SQL_BATCH) {\n          this.isSqlBatch = true;\n        } else {\n          this.isSqlBatch = false;\n        }\n\n        this.request = request;\n        this.request.rowCount = 0;\n        this.request.rows = [];\n        this.request.rst = [];\n        this.createRequestTimer();\n        this.messageIo.sendMessage(packetType, payload.data, this.resetConnectionOnNextRequest);\n        this.resetConnectionOnNextRequest = false;\n        this.debug.payload(function () {\n          return payload.toString('  ');\n        });\n        return this.transitionTo(this.STATE.SENT_CLIENT_REQUEST);\n      }\n    }\n  }, {\n    key: 'cancel',\n    value: function cancel() {\n      if (this.state !== this.STATE.SENT_CLIENT_REQUEST) {\n        var message = 'Requests can only be canceled in the ' + this.STATE.SENT_CLIENT_REQUEST.name + ' state, not the ' + this.state.name + ' state';\n        this.debug.log(message);\n        return false;\n      } else {\n        this.request.canceled = true;\n        this.messageIo.sendMessage(TYPE.ATTENTION);\n        this.transitionTo(this.STATE.SENT_ATTENTION);\n        return true;\n      }\n    }\n  }, {\n    key: 'reset',\n    value: function reset(callback) {\n      var self = this;\n      var request = new Request(this.getInitialSql(), function (err) {\n        if (self.config.options.tdsVersion < '7_2') {\n          self.inTransaction = false;\n        }\n        return callback(err);\n      });\n      this.resetConnectionOnNextRequest = true;\n      return this.execSqlBatch(request);\n    }\n  }, {\n    key: 'currentTransactionDescriptor',\n    value: function currentTransactionDescriptor() {\n      return this.transactionDescriptors[this.transactionDescriptors.length - 1];\n    }\n  }, {\n    key: 'getIsolationLevelText',\n    value: function getIsolationLevelText(isolationLevel) {\n      switch (isolationLevel) {\n        case ISOLATION_LEVEL.READ_UNCOMMITTED:\n          return 'read uncommitted';\n        case ISOLATION_LEVEL.REPEATABLE_READ:\n          return 'repeatable read';\n        case ISOLATION_LEVEL.SERIALIZABLE:\n          return 'serializable';\n        case ISOLATION_LEVEL.SNAPSHOT:\n          return 'snapshot';\n        default:\n          return 'read committed';\n      }\n    }\n  }]);\n  return Connection;\n}(EventEmitter);\n\nmodule.exports = Connection;\n\nConnection.prototype.STATE = {\n  CONNECTING: {\n    name: 'Connecting',\n    enter: function enter() {\n      return this.initialiseConnection();\n    },\n    events: {\n      socketError: function socketError() {\n        return this.transitionTo(this.STATE.FINAL);\n      },\n      connectTimeout: function connectTimeout() {\n        return this.transitionTo(this.STATE.FINAL);\n      },\n      socketConnect: function socketConnect() {\n        this.sendPreLogin();\n        return this.transitionTo(this.STATE.SENT_PRELOGIN);\n      }\n    }\n  },\n  SENT_PRELOGIN: {\n    name: 'SentPrelogin',\n    enter: function enter() {\n      return this.emptyMessageBuffer();\n    },\n    events: {\n      socketError: function socketError() {\n        return this.transitionTo(this.STATE.FINAL);\n      },\n      connectTimeout: function connectTimeout() {\n        return this.transitionTo(this.STATE.FINAL);\n      },\n      data: function data(_data) {\n        return this.addToMessageBuffer(_data);\n      },\n      message: function message() {\n        return this.processPreLoginResponse();\n      },\n      noTls: function noTls() {\n        this.sendLogin7Packet();\n        if (this.config.domain) {\n          return this.transitionTo(this.STATE.SENT_LOGIN7_WITH_NTLM);\n        } else {\n          return this.transitionTo(this.STATE.SENT_LOGIN7_WITH_STANDARD_LOGIN);\n        }\n      },\n      tls: function tls() {\n        this.messageIo.startTls(this.config.options.cryptoCredentialsDetails, this.config.server, this.config.options.trustServerCertificate);\n        return this.transitionTo(this.STATE.SENT_TLSSSLNEGOTIATION);\n      }\n    }\n  },\n  REROUTING: {\n    name: 'ReRouting',\n    enter: function enter() {\n      return this.cleanupConnection(true);\n    },\n    events: {\n      message: function message() {},\n      socketError: function socketError() {\n        return this.transitionTo(this.STATE.FINAL);\n      },\n      connectTimeout: function connectTimeout() {\n        return this.transitionTo(this.STATE.FINAL);\n      },\n      reconnect: function reconnect() {\n        return this.transitionTo(this.STATE.CONNECTING);\n      }\n    }\n  },\n  SENT_TLSSSLNEGOTIATION: {\n    name: 'SentTLSSSLNegotiation',\n    events: {\n      socketError: function socketError() {\n        return this.transitionTo(this.STATE.FINAL);\n      },\n      connectTimeout: function connectTimeout() {\n        return this.transitionTo(this.STATE.FINAL);\n      },\n      data: function data(_data2) {\n        return this.messageIo.tlsHandshakeData(_data2);\n      },\n      message: function message() {\n        if (this.messageIo.tlsNegotiationComplete) {\n          this.sendLogin7Packet();\n          if (this.config.domain) {\n            return this.transitionTo(this.STATE.SENT_LOGIN7_WITH_NTLM);\n          } else {\n            return this.transitionTo(this.STATE.SENT_LOGIN7_WITH_STANDARD_LOGIN);\n          }\n        }\n      }\n    }\n  },\n  SENT_LOGIN7_WITH_STANDARD_LOGIN: {\n    name: 'SentLogin7WithStandardLogin',\n    events: {\n      socketError: function socketError() {\n        return this.transitionTo(this.STATE.FINAL);\n      },\n      connectTimeout: function connectTimeout() {\n        return this.transitionTo(this.STATE.FINAL);\n      },\n      data: function data(_data3) {\n        return this.sendDataToTokenStreamParser(_data3);\n      },\n      loggedIn: function loggedIn() {\n        return this.transitionTo(this.STATE.LOGGED_IN_SENDING_INITIAL_SQL);\n      },\n      routingChange: function routingChange() {\n        return this.transitionTo(this.STATE.REROUTING);\n      },\n      loginFailed: function loginFailed() {\n        return this.transitionTo(this.STATE.FINAL);\n      },\n      message: function message() {\n        return this.processLogin7Response();\n      }\n    }\n  },\n  SENT_LOGIN7_WITH_NTLM: {\n    name: 'SentLogin7WithNTLMLogin',\n    events: {\n      socketError: function socketError() {\n        return this.transitionTo(this.STATE.FINAL);\n      },\n      connectTimeout: function connectTimeout() {\n        return this.transitionTo(this.STATE.FINAL);\n      },\n      data: function data(_data4) {\n        return this.sendDataToTokenStreamParser(_data4);\n      },\n      receivedChallenge: function receivedChallenge() {\n        this.sendNTLMResponsePacket();\n        return this.transitionTo(this.STATE.SENT_NTLM_RESPONSE);\n      },\n      loginFailed: function loginFailed() {\n        return this.transitionTo(this.STATE.FINAL);\n      },\n      message: function message() {\n        return this.processLogin7NTLMResponse();\n      }\n    }\n  },\n  SENT_NTLM_RESPONSE: {\n    name: 'SentNTLMResponse',\n    events: {\n      socketError: function socketError() {\n        return this.transitionTo(this.STATE.FINAL);\n      },\n      connectTimeout: function connectTimeout() {\n        return this.transitionTo(this.STATE.FINAL);\n      },\n      data: function data(_data5) {\n        return this.sendDataToTokenStreamParser(_data5);\n      },\n      loggedIn: function loggedIn() {\n        return this.transitionTo(this.STATE.LOGGED_IN_SENDING_INITIAL_SQL);\n      },\n      loginFailed: function loginFailed() {\n        return this.transitionTo(this.STATE.FINAL);\n      },\n      routingChange: function routingChange() {\n        return this.transitionTo(this.STATE.REROUTING);\n      },\n      message: function message() {\n        return this.processLogin7NTLMAck();\n      }\n    }\n  },\n  LOGGED_IN_SENDING_INITIAL_SQL: {\n    name: 'LoggedInSendingInitialSql',\n    enter: function enter() {\n      return this.sendInitialSql();\n    },\n    events: {\n      connectTimeout: function connectTimeout() {\n        return this.transitionTo(this.STATE.FINAL);\n      },\n      data: function data(_data6) {\n        return this.sendDataToTokenStreamParser(_data6);\n      },\n      message: function message() {\n        this.transitionTo(this.STATE.LOGGED_IN);\n        return this.processedInitialSql();\n      }\n    }\n  },\n  LOGGED_IN: {\n    name: 'LoggedIn',\n    events: {\n      socketError: function socketError() {\n        return this.transitionTo(this.STATE.FINAL);\n      }\n    }\n  },\n  SENT_CLIENT_REQUEST: {\n    name: 'SentClientRequest',\n    exit: function exit() {\n      this.clearRequestTimer();\n    },\n    events: {\n      socketError: function socketError(err) {\n        var sqlRequest = this.request;\n        this.request = undefined;\n        sqlRequest.callback(err);\n        return this.transitionTo(this.STATE.FINAL);\n      },\n      data: function data(_data7) {\n        this.clearRequestTimer(); // request timer is stopped on first data package\n        return this.sendDataToTokenStreamParser(_data7);\n      },\n      message: function message() {\n        this.transitionTo(this.STATE.LOGGED_IN);\n        var sqlRequest = this.request;\n        this.request = undefined;\n        if (this.config.options.tdsVersion < '7_2' && sqlRequest.error && this.isSqlBatch) {\n          this.inTransaction = false;\n        }\n        return sqlRequest.callback(sqlRequest.error, sqlRequest.rowCount, sqlRequest.rows);\n      }\n    }\n  },\n  SENT_ATTENTION: {\n    name: 'SentAttention',\n    enter: function enter() {\n      return this.attentionReceived = false;\n    },\n    events: {\n      socketError: function socketError() {\n        return this.transitionTo(this.STATE.FINAL);\n      },\n      data: function data(_data8) {\n        return this.sendDataToTokenStreamParser(_data8);\n      },\n      attention: function attention() {\n        return this.attentionReceived = true;\n      },\n      message: function message() {\n        // 3.2.5.7 Sent Attention State\n        // Discard any data contained in the response, until we receive the attention response\n        if (this.attentionReceived) {\n          var sqlRequest = this.request;\n          this.request = undefined;\n          this.transitionTo(this.STATE.LOGGED_IN);\n          if (sqlRequest.canceled) {\n            return sqlRequest.callback(RequestError('Canceled.', 'ECANCEL'));\n          } else {\n            var message = 'Timeout: Request failed to complete in ' + this.config.options.requestTimeout + 'ms';\n            return sqlRequest.callback(RequestError(message, 'ETIMEOUT'));\n          }\n        }\n      }\n    }\n  },\n  FINAL: {\n    name: 'Final',\n    enter: function enter() {\n      return this.cleanupConnection();\n    },\n    events: {\n      loginFailed: function loginFailed() {\n        // Do nothing. The connection was probably closed by the client code.\n      },\n      connectTimeout: function connectTimeout() {\n        // Do nothing, as the timer should be cleaned up.\n      },\n      message: function message() {\n        // Do nothing\n      },\n      socketError: function socketError() {\n        // Do nothing\n      }\n    }\n  }\n};","/home/travis/build/npmtest/node-npmtest-tedious/tedious/lib/debug.js":"'use strict';\n\nvar _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = require('babel-runtime/helpers/inherits');\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar EventEmitter = require('events').EventEmitter;\nvar util = require('util');\n\nmodule.exports = function (_EventEmitter) {\n  (0, _inherits3.default)(Debug, _EventEmitter);\n\n  /*\n    @options    Which debug details should be sent.\n                data    - dump of packet data\n                payload - details of decoded payload\n  */\n  function Debug(options) {\n    (0, _classCallCheck3.default)(this, Debug);\n\n    var _this = (0, _possibleConstructorReturn3.default)(this, (Debug.__proto__ || (0, _getPrototypeOf2.default)(Debug)).call(this));\n\n    _this.options = options;\n    _this.options = _this.options || {};\n    _this.options.data = _this.options.data || false;\n    _this.options.payload = _this.options.payload || false;\n    _this.options.packet = _this.options.packet || false;\n    _this.options.token = _this.options.token || false;\n    _this.indent = '  ';\n    return _this;\n  }\n\n  (0, _createClass3.default)(Debug, [{\n    key: 'packet',\n    value: function packet(direction, _packet) {\n      if (this.haveListeners() && this.options.packet) {\n        this.log('');\n        this.log(direction);\n        this.log(_packet.headerToString(this.indent));\n      }\n    }\n  }, {\n    key: 'data',\n    value: function data(packet) {\n      if (this.haveListeners() && this.options.data) {\n        this.log(packet.dataToString(this.indent));\n      }\n    }\n  }, {\n    key: 'payload',\n    value: function payload(generatePayloadText) {\n      if (this.haveListeners() && this.options.payload) {\n        this.log(generatePayloadText());\n      }\n    }\n  }, {\n    key: 'token',\n    value: function token(_token) {\n      if (this.haveListeners() && this.options.token) {\n        this.log(util.inspect(_token, false, 5, true));\n      }\n    }\n  }, {\n    key: 'haveListeners',\n    value: function haveListeners() {\n      return this.listeners('debug').length > 0;\n    }\n  }, {\n    key: 'log',\n    value: function log(text) {\n      this.emit('debug', text);\n    }\n  }]);\n  return Debug;\n}(EventEmitter);","/home/travis/build/npmtest/node-npmtest-tedious/tedious/lib/instance-lookup.js":"'use strict';\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar Sender = require('./sender').Sender;\n\nvar SQL_SERVER_BROWSER_PORT = 1434;\nvar TIMEOUT = 2 * 1000;\nvar RETRIES = 3;\n// There are three bytes at the start of the response, whose purpose is unknown.\nvar MYSTERY_HEADER_LENGTH = 3;\n\n// Most of the functionality has been determined from from jTDS's MSSqlServerInfo class.\n\nvar InstanceLookup = function () {\n  function InstanceLookup() {\n    (0, _classCallCheck3.default)(this, InstanceLookup);\n  }\n\n  // Wrapper allows for stubbing Sender when unit testing instance-lookup.\n\n\n  (0, _createClass3.default)(InstanceLookup, [{\n    key: 'createSender',\n    value: function createSender(host, port, request) {\n      return new Sender(host, port, request);\n    }\n  }, {\n    key: 'instanceLookup',\n    value: function instanceLookup(options, callback) {\n      var _this = this;\n\n      var server = options.server;\n      if (typeof server !== 'string') {\n        throw new TypeError('Invalid arguments: \"server\" must be a string');\n      }\n\n      var instanceName = options.instanceName;\n      if (typeof instanceName !== 'string') {\n        throw new TypeError('Invalid arguments: \"instanceName\" must be a string');\n      }\n\n      var timeout = options.timeout === undefined ? TIMEOUT : options.timeout;\n      if (typeof timeout !== 'number') {\n        throw new TypeError('Invalid arguments: \"timeout\" must be a number');\n      }\n\n      var retries = options.retries === undefined ? RETRIES : options.retries;\n      if (typeof retries !== 'number') {\n        throw new TypeError('Invalid arguments: \"retries\" must be a number');\n      }\n\n      if (typeof callback !== 'function') {\n        throw new TypeError('Invalid arguments: \"callback\" must be a function');\n      }\n\n      var sender = void 0,\n          timer = void 0,\n          retriesLeft = retries;\n\n      var onTimeout = function onTimeout() {\n        sender.cancel();\n        return makeAttempt();\n      };\n\n      var makeAttempt = function makeAttempt() {\n        if (retriesLeft > 0) {\n          retriesLeft--;\n\n          var request = new Buffer([0x02]);\n          sender = _this.createSender(options.server, SQL_SERVER_BROWSER_PORT, request);\n          sender.execute(function (err, message) {\n            clearTimeout(timer);\n            if (err) {\n              return callback('Failed to lookup instance on ' + server + ' - ' + err.message);\n            } else {\n              message = message.toString('ascii', MYSTERY_HEADER_LENGTH);\n              var port = _this.parseBrowserResponse(message, instanceName);\n\n              if (port) {\n                return callback(undefined, port);\n              } else {\n                return callback('Port for ' + instanceName + ' not found in ' + message);\n              }\n            }\n          });\n\n          return timer = setTimeout(onTimeout, timeout);\n        } else {\n          return callback('Failed to get response from SQL Server Browser on ' + server);\n        }\n      };\n\n      return makeAttempt();\n    }\n  }, {\n    key: 'parseBrowserResponse',\n    value: function parseBrowserResponse(response, instanceName) {\n      var getPort = void 0;\n\n      var instances = response.split(';;');\n      for (var i = 0, len = instances.length; i < len; i++) {\n        var instance = instances[i];\n        var parts = instance.split(';');\n\n        for (var p = 0, partsLen = parts.length; p < partsLen; p += 2) {\n          var name = parts[p];\n          var value = parts[p + 1];\n\n          if (name === 'tcp' && getPort) {\n            var port = parseInt(value, 10);\n            return port;\n          }\n\n          if (name === 'InstanceName') {\n            if (value.toUpperCase() === instanceName.toUpperCase()) {\n              getPort = true;\n            } else {\n              getPort = false;\n            }\n          }\n        }\n      }\n    }\n  }]);\n  return InstanceLookup;\n}();\n\nmodule.exports.InstanceLookup = InstanceLookup;","/home/travis/build/npmtest/node-npmtest-tedious/tedious/lib/sender.js":"'use strict';\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar dgram = require('dgram');\nvar dns = require('dns');\nvar net = require('net');\n\nvar Sender = function () {\n  function Sender(host, port, request) {\n    (0, _classCallCheck3.default)(this, Sender);\n\n    this.host = host;\n    this.port = port;\n    this.request = request;\n\n    this.parallelSendStrategy = null;\n  }\n\n  (0, _createClass3.default)(Sender, [{\n    key: 'execute',\n    value: function execute(cb) {\n      if (net.isIP(this.host)) {\n        this.executeForIP(cb);\n      } else {\n        this.executeForHostname(cb);\n      }\n    }\n  }, {\n    key: 'executeForIP',\n    value: function executeForIP(cb) {\n      this.executeForAddresses([{ address: this.host }], cb);\n    }\n\n    // Wrapper for stubbing. Sinon does not have support for stubbing module functions.\n\n  }, {\n    key: 'invokeLookupAll',\n    value: function invokeLookupAll(host, cb) {\n      dns.lookup(host, { all: true }, cb);\n    }\n  }, {\n    key: 'executeForHostname',\n    value: function executeForHostname(cb) {\n      var _this = this;\n\n      this.invokeLookupAll(this.host, function (err, addresses) {\n        if (err) {\n          return cb(err);\n        }\n\n        _this.executeForAddresses(addresses, cb);\n      });\n    }\n\n    // Wrapper for stubbing creation of Strategy object. Sinon support for constructors\n    // seems limited.\n\n  }, {\n    key: 'createParallelSendStrategy',\n    value: function createParallelSendStrategy(addresses, port, request) {\n      return new ParallelSendStrategy(addresses, port, request);\n    }\n  }, {\n    key: 'executeForAddresses',\n    value: function executeForAddresses(addresses, cb) {\n      this.parallelSendStrategy = this.createParallelSendStrategy(addresses, this.port, this.request);\n      this.parallelSendStrategy.send(cb);\n    }\n  }, {\n    key: 'cancel',\n    value: function cancel() {\n      if (this.parallelSendStrategy) {\n        this.parallelSendStrategy.cancel();\n      }\n    }\n  }]);\n  return Sender;\n}();\n\nvar ParallelSendStrategy = function () {\n  function ParallelSendStrategy(addresses, port, request) {\n    (0, _classCallCheck3.default)(this, ParallelSendStrategy);\n\n    this.addresses = addresses;\n    this.port = port;\n    this.request = request;\n\n    this.socketV4 = null;\n    this.socketV6 = null;\n    this.onError = null;\n    this.onMessage = null;\n  }\n\n  (0, _createClass3.default)(ParallelSendStrategy, [{\n    key: 'clearSockets',\n    value: function clearSockets() {\n      var clearSocket = function clearSocket(socket, onError, onMessage) {\n        socket.removeListener('error', onError);\n        socket.removeListener('message', onMessage);\n        socket.close();\n      };\n\n      if (this.socketV4) {\n        clearSocket(this.socketV4, this.onError, this.onMessage);\n        this.socketV4 = null;\n      }\n\n      if (this.socketV6) {\n        clearSocket(this.socketV6, this.onError, this.onMessage);\n        this.socketV6 = null;\n      }\n    }\n  }, {\n    key: 'send',\n    value: function send(cb) {\n      var _this2 = this;\n\n      var errorCount = 0;\n\n      var onError = function onError(err) {\n        errorCount++;\n\n        if (errorCount === _this2.addresses.length) {\n          _this2.clearSockets();\n          cb(err);\n        }\n      };\n\n      var onMessage = function onMessage(message) {\n        _this2.clearSockets();\n        cb(null, message);\n      };\n\n      var createDgramSocket = function createDgramSocket(udpType, onError, onMessage) {\n        var socket = dgram.createSocket(udpType);\n\n        socket.on('error', onError);\n        socket.on('message', onMessage);\n        return socket;\n      };\n\n      for (var j = 0; j < this.addresses.length; j++) {\n        var udpTypeV4 = 'udp4';\n        var udpTypeV6 = 'udp6';\n\n        var udpType = net.isIPv4(this.addresses[j].address) ? udpTypeV4 : udpTypeV6;\n        var socket = void 0;\n\n        if (udpType === udpTypeV4) {\n          if (!this.socketV4) {\n            this.socketV4 = createDgramSocket(udpTypeV4, onError, onMessage);\n          }\n\n          socket = this.socketV4;\n        } else {\n          if (!this.socketV6) {\n            this.socketV6 = createDgramSocket(udpTypeV6, onError, onMessage);\n          }\n\n          socket = this.socketV6;\n        }\n\n        socket.send(this.request, 0, this.request.length, this.port, this.addresses[j].address);\n      }\n\n      this.onError = onError;\n      this.onMessage = onMessage;\n    }\n  }, {\n    key: 'cancel',\n    value: function cancel() {\n      this.clearSockets();\n    }\n  }]);\n  return ParallelSendStrategy;\n}();\n\nmodule.exports.Sender = Sender;\nmodule.exports.ParallelSendStrategy = ParallelSendStrategy;","/home/travis/build/npmtest/node-npmtest-tedious/tedious/lib/packet.js":"'use strict';\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar sprintf = require('sprintf').sprintf;\n\nvar HEADER_LENGTH = module.exports.HEADER_LENGTH = 8;\n\nvar TYPE = module.exports.TYPE = {\n  SQL_BATCH: 0x01,\n  RPC_REQUEST: 0x03,\n  TABULAR_RESULT: 0x04,\n  ATTENTION: 0x06,\n  BULK_LOAD: 0x07,\n  TRANSACTION_MANAGER: 0x0E,\n  LOGIN7: 0x10,\n  NTLMAUTH_PKT: 0x11,\n  PRELOGIN: 0x12\n};\n\nvar typeByValue = {};\n\nfor (var name in TYPE) {\n  typeByValue[TYPE[name]] = name;\n}\n\nvar STATUS = {\n  NORMAL: 0x00,\n  EOM: 0x01,\n  IGNORE: 0x02,\n  RESETCONNECTION: 0x08,\n  RESETCONNECTIONSKIPTRAN: 0x10\n};\n\nvar OFFSET = module.exports.OFFSET = {\n  Type: 0,\n  Status: 1,\n  Length: 2,\n  SPID: 4,\n  PacketID: 6,\n  Window: 7\n};\n\nvar DEFAULT_SPID = 0;\n\nvar DEFAULT_PACKETID = 1;\n\nvar DEFAULT_WINDOW = 0;\n\nvar NL = '\\n';\n\nvar Packet = function () {\n  function Packet(typeOrBuffer) {\n    (0, _classCallCheck3.default)(this, Packet);\n\n    if (typeOrBuffer instanceof Buffer) {\n      this.buffer = typeOrBuffer;\n    } else {\n      var type = typeOrBuffer;\n      this.buffer = new Buffer(HEADER_LENGTH);\n      this.buffer.writeUInt8(type, OFFSET.Type);\n      this.buffer.writeUInt8(STATUS.NORMAL, OFFSET.Status);\n      this.buffer.writeUInt16BE(DEFAULT_SPID, OFFSET.SPID);\n      this.buffer.writeUInt8(DEFAULT_PACKETID, OFFSET.PacketID);\n      this.buffer.writeUInt8(DEFAULT_WINDOW, OFFSET.Window);\n      this.setLength();\n    }\n  }\n\n  (0, _createClass3.default)(Packet, [{\n    key: 'setLength',\n    value: function setLength() {\n      return this.buffer.writeUInt16BE(this.buffer.length, OFFSET.Length);\n    }\n  }, {\n    key: 'length',\n    value: function length() {\n      return this.buffer.readUInt16BE(OFFSET.Length);\n    }\n  }, {\n    key: 'resetConnection',\n    value: function resetConnection(reset) {\n      var status = this.buffer.readUInt8(OFFSET.Status);\n      if (reset) {\n        status |= STATUS.RESETCONNECTION;\n      } else {\n        status &= 0xFF - STATUS.RESETCONNECTION;\n      }\n      return this.buffer.writeUInt8(status, OFFSET.Status);\n    }\n  }, {\n    key: 'last',\n    value: function last(_last) {\n      var status = this.buffer.readUInt8(OFFSET.Status);\n      if (arguments.length > 0) {\n        if (_last) {\n          status |= STATUS.EOM;\n        } else {\n          status &= 0xFF - STATUS.EOM;\n        }\n        this.buffer.writeUInt8(status, OFFSET.Status);\n      }\n      return this.isLast();\n    }\n  }, {\n    key: 'isLast',\n    value: function isLast() {\n      return !!(this.buffer.readUInt8(OFFSET.Status) & STATUS.EOM);\n    }\n  }, {\n    key: 'packetId',\n    value: function packetId(_packetId) {\n      if (_packetId) {\n        this.buffer.writeUInt8(_packetId % 256, OFFSET.PacketID);\n      }\n      return this.buffer.readUInt8(OFFSET.PacketID);\n    }\n  }, {\n    key: 'addData',\n    value: function addData(data) {\n      this.buffer = Buffer.concat([this.buffer, data]);\n      this.setLength();\n      return this;\n    }\n  }, {\n    key: 'data',\n    value: function data() {\n      return this.buffer.slice(HEADER_LENGTH);\n    }\n  }, {\n    key: 'type',\n    value: function type() {\n      return this.buffer.readUInt8(OFFSET.Type);\n    }\n  }, {\n    key: 'statusAsString',\n    value: function statusAsString() {\n      var status = this.buffer.readUInt8(OFFSET.Status);\n      var statuses = [];\n\n      for (var _name in STATUS) {\n        var value = STATUS[_name];\n\n        if (status & value) {\n          statuses.push(_name);\n        } else {\n          statuses.push(undefined);\n        }\n      }\n\n      return statuses.join(' ').trim();\n    }\n  }, {\n    key: 'headerToString',\n    value: function headerToString(indent) {\n      indent || (indent = '');\n      var text = sprintf('type:0x%02X(%s), status:0x%02X(%s), length:0x%04X, spid:0x%04X, packetId:0x%02X, window:0x%02X', this.buffer.readUInt8(OFFSET.Type), typeByValue[this.buffer.readUInt8(OFFSET.Type)], this.buffer.readUInt8(OFFSET.Status), this.statusAsString(), this.buffer.readUInt16BE(OFFSET.Length), this.buffer.readUInt16BE(OFFSET.SPID), this.buffer.readUInt8(OFFSET.PacketID), this.buffer.readUInt8(OFFSET.Window));\n      return indent + text;\n    }\n  }, {\n    key: 'dataToString',\n    value: function dataToString(indent) {\n      indent || (indent = '');\n\n      var BYTES_PER_GROUP = 0x04;\n      var CHARS_PER_GROUP = 0x08;\n      var BYTES_PER_LINE = 0x20;\n      var data = this.data();\n\n      var dataDump = '';\n      var chars = '';\n\n      for (var offset = 0; offset < data.length; offset++) {\n        if (offset % BYTES_PER_LINE === 0) {\n          dataDump += indent;\n          dataDump += sprintf('%04X  ', offset);\n        }\n\n        if (data[offset] < 0x20 || data[offset] > 0x7E) {\n          chars += '.';\n          if ((offset + 1) % CHARS_PER_GROUP === 0 && !((offset + 1) % BYTES_PER_LINE === 0)) {\n            chars += ' ';\n          }\n        } else {\n          chars += String.fromCharCode(data[offset]);\n        }\n\n        if (data[offset] != null) {\n          dataDump += sprintf('%02X', data[offset]);\n        }\n\n        if ((offset + 1) % BYTES_PER_GROUP === 0 && !((offset + 1) % BYTES_PER_LINE === 0)) {\n          dataDump += ' ';\n        }\n\n        if ((offset + 1) % BYTES_PER_LINE === 0) {\n          dataDump += '  ' + chars;\n          chars = '';\n          if (offset < data.length - 1) {\n            dataDump += NL;\n          }\n        }\n      }\n\n      if (chars.length) {\n        dataDump += '  ' + chars;\n      }\n\n      return dataDump;\n    }\n  }, {\n    key: 'toString',\n    value: function toString(indent) {\n      indent || (indent = '');\n      return this.headerToString(indent) + '\\n' + this.dataToString(indent + indent);\n    }\n  }, {\n    key: 'payloadString',\n    value: function payloadString() {\n      return '';\n    }\n  }]);\n  return Packet;\n}();\n\nmodule.exports.Packet = Packet;\n\nmodule.exports.isPacketComplete = isPacketComplete;\nfunction isPacketComplete(potentialPacketBuffer) {\n  if (potentialPacketBuffer.length < HEADER_LENGTH) {\n    return false;\n  } else {\n    return potentialPacketBuffer.length >= potentialPacketBuffer.readUInt16BE(OFFSET.Length);\n  }\n}\n\nmodule.exports.packetLength = packetLength;\nfunction packetLength(potentialPacketBuffer) {\n  return potentialPacketBuffer.readUInt16BE(OFFSET.Length);\n}","/home/travis/build/npmtest/node-npmtest-tedious/tedious/lib/prelogin-payload.js":"'use strict';\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar sprintf = require('sprintf').sprintf;\nvar WritableTrackingBuffer = require('./tracking-buffer/tracking-buffer').WritableTrackingBuffer;\n\nvar optionBufferSize = 20;\n\nvar VERSION = 0x000000001;\n\nvar SUBBUILD = 0x0001;\n\nvar TOKEN = {\n  VERSION: 0x00,\n  ENCRYPTION: 0x01,\n  INSTOPT: 0x02,\n  THREADID: 0x03,\n  MARS: 0x04,\n  TERMINATOR: 0xFF\n};\n\nvar ENCRYPT = {\n  OFF: 0x00,\n  ON: 0x01,\n  NOT_SUP: 0x02,\n  REQ: 0x03\n};\n\nvar encryptByValue = {};\n\nfor (var name in ENCRYPT) {\n  var value = ENCRYPT[name];\n  encryptByValue[value] = name;\n}\n\nvar MARS = {\n  OFF: 0x00,\n  ON: 0x01\n};\n\nvar marsByValue = {};\n\nfor (var _name in MARS) {\n  var _value = MARS[_name];\n  marsByValue[_value] = _name;\n}\n\n/*\n  s2.2.6.4\n */\nmodule.exports = function () {\n  function PreloginPayload(bufferOrOptions) {\n    (0, _classCallCheck3.default)(this, PreloginPayload);\n\n    if (bufferOrOptions instanceof Buffer) {\n      this.data = bufferOrOptions;\n    } else {\n      this.options = bufferOrOptions || {};\n      this.createOptions();\n    }\n    this.extractOptions();\n  }\n\n  (0, _createClass3.default)(PreloginPayload, [{\n    key: 'createOptions',\n    value: function createOptions() {\n      var options = [this.createVersionOption(), this.createEncryptionOption(), this.createInstanceOption(), this.createThreadIdOption(), this.createMarsOption()];\n\n      var length = 0;\n      for (var i = 0, len = options.length; i < len; i++) {\n        var option = options[i];\n        length += 5 + option.data.length;\n      }\n      length++; // terminator\n      this.data = new Buffer(length);\n      var optionOffset = 0;\n      var optionDataOffset = 5 * options.length + 1;\n\n      for (var j = 0, _len = options.length; j < _len; j++) {\n        var _option = options[j];\n        this.data.writeUInt8(_option.token, optionOffset + 0);\n        this.data.writeUInt16BE(optionDataOffset, optionOffset + 1);\n        this.data.writeUInt16BE(_option.data.length, optionOffset + 3);\n        optionOffset += 5;\n        _option.data.copy(this.data, optionDataOffset);\n        optionDataOffset += _option.data.length;\n      }\n\n      return this.data.writeUInt8(TOKEN.TERMINATOR, optionOffset);\n    }\n  }, {\n    key: 'createVersionOption',\n    value: function createVersionOption() {\n      var buffer = new WritableTrackingBuffer(optionBufferSize);\n      buffer.writeUInt32BE(VERSION);\n      buffer.writeUInt16BE(SUBBUILD);\n      return {\n        token: TOKEN.VERSION,\n        data: buffer.data\n      };\n    }\n  }, {\n    key: 'createEncryptionOption',\n    value: function createEncryptionOption() {\n      var buffer = new WritableTrackingBuffer(optionBufferSize);\n      if (this.options.encrypt) {\n        buffer.writeUInt8(ENCRYPT.ON);\n      } else {\n        buffer.writeUInt8(ENCRYPT.NOT_SUP);\n      }\n      return {\n        token: TOKEN.ENCRYPTION,\n        data: buffer.data\n      };\n    }\n  }, {\n    key: 'createInstanceOption',\n    value: function createInstanceOption() {\n      var buffer = new WritableTrackingBuffer(optionBufferSize);\n      buffer.writeUInt8(0x00);\n      return {\n        token: TOKEN.INSTOPT,\n        data: buffer.data\n      };\n    }\n  }, {\n    key: 'createThreadIdOption',\n    value: function createThreadIdOption() {\n      var buffer = new WritableTrackingBuffer(optionBufferSize);\n      buffer.writeUInt32BE(0x00);\n      return {\n        token: TOKEN.THREADID,\n        data: buffer.data\n      };\n    }\n  }, {\n    key: 'createMarsOption',\n    value: function createMarsOption() {\n      var buffer = new WritableTrackingBuffer(optionBufferSize);\n      buffer.writeUInt8(MARS.OFF);\n      return {\n        token: TOKEN.MARS,\n        data: buffer.data\n      };\n    }\n  }, {\n    key: 'extractOptions',\n    value: function extractOptions() {\n      var offset = 0;\n      while (this.data[offset] !== TOKEN.TERMINATOR) {\n        var dataOffset = this.data.readUInt16BE(offset + 1);\n        var dataLength = this.data.readUInt16BE(offset + 3);\n        switch (this.data[offset]) {\n          case TOKEN.VERSION:\n            this.extractVersion(dataOffset);\n            break;\n          case TOKEN.ENCRYPTION:\n            this.extractEncryption(dataOffset);\n            break;\n          case TOKEN.INSTOPT:\n            this.extractInstance(dataOffset);\n            break;\n          case TOKEN.THREADID:\n            if (dataLength > 0) {\n              this.extractThreadId(dataOffset);\n            }\n            break;\n          case TOKEN.MARS:\n            this.extractMars(dataOffset);\n        }\n        offset += 5;\n        dataOffset += dataLength;\n      }\n    }\n  }, {\n    key: 'extractVersion',\n    value: function extractVersion(offset) {\n      return this.version = {\n        major: this.data.readUInt8(offset + 0),\n        minor: this.data.readUInt8(offset + 1),\n        patch: this.data.readUInt8(offset + 2),\n        trivial: this.data.readUInt8(offset + 3),\n        subbuild: this.data.readUInt16BE(offset + 4)\n      };\n    }\n  }, {\n    key: 'extractEncryption',\n    value: function extractEncryption(offset) {\n      this.encryption = this.data.readUInt8(offset);\n      return this.encryptionString = encryptByValue[this.encryption];\n    }\n  }, {\n    key: 'extractInstance',\n    value: function extractInstance(offset) {\n      return this.instance = this.data.readUInt8(offset);\n    }\n  }, {\n    key: 'extractThreadId',\n    value: function extractThreadId(offset) {\n      return this.threadId = this.data.readUInt32BE(offset);\n    }\n  }, {\n    key: 'extractMars',\n    value: function extractMars(offset) {\n      this.mars = this.data.readUInt8(offset);\n      return this.marsString = marsByValue[this.mars];\n    }\n  }, {\n    key: 'toString',\n    value: function toString(indent) {\n      indent || (indent = '');\n      return indent + 'PreLogin - ' + sprintf('version:%d.%d.%d.%d %d, encryption:0x%02X(%s), instopt:0x%02X, threadId:0x%08X, mars:0x%02X(%s)', this.version.major, this.version.minor, this.version.patch, this.version.trivial, this.version.subbuild, this.encryption ? this.encryption : 0, this.encryptionString ? this.encryptionString : 0, this.instance ? this.instance : 0, this.threadId ? this.threadId : 0, this.mars ? this.mars : 0, this.marsString ? this.marsString : 0);\n    }\n  }]);\n  return PreloginPayload;\n}();","/home/travis/build/npmtest/node-npmtest-tedious/tedious/lib/login7-payload.js":"'use strict';\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar WritableTrackingBuffer = require('./tracking-buffer/writable-tracking-buffer');\nvar os = require('os');\nvar sprintf = require('sprintf').sprintf;\nvar libraryName = require('./library').name;\nvar versions = require('./tds-versions').versions;\n\nvar FLAGS_1 = {\n  ENDIAN_LITTLE: 0x00,\n  ENDIAN_BIG: 0x01,\n  CHARSET_ASCII: 0x00,\n  CHARSET_EBCDIC: 0x02,\n  FLOAT_IEEE_754: 0x00,\n  FLOAT_VAX: 0x04,\n  FLOAT_ND5000: 0x08,\n  BCP_DUMPLOAD_ON: 0x00,\n  BCP_DUMPLOAD_OFF: 0x10,\n  USE_DB_ON: 0x00,\n  USE_DB_OFF: 0x20,\n  INIT_DB_WARN: 0x00,\n  INIT_DB_FATAL: 0x40,\n  SET_LANG_WARN_OFF: 0x00,\n  SET_LANG_WARN_ON: 0x80\n};\n\nvar FLAGS_2 = {\n  INIT_LANG_WARN: 0x00,\n  INIT_LANG_FATAL: 0x01,\n  ODBC_OFF: 0x00,\n  ODBC_ON: 0x02,\n  F_TRAN_BOUNDARY: 0x04,\n  F_CACHE_CONNECT: 0x08,\n  USER_NORMAL: 0x00,\n  USER_SERVER: 0x10,\n  USER_REMUSER: 0x20,\n  USER_SQLREPL: 0x40,\n  INTEGRATED_SECURITY_OFF: 0x00,\n  INTEGRATED_SECURITY_ON: 0x80\n};\n\nvar TYPE_FLAGS = {\n  SQL_DFLT: 0x00,\n  SQL_TSQL: 0x08,\n  OLEDB_OFF: 0x00,\n  OLEDB_ON: 0x10,\n  READ_WRITE_INTENT: 0x00,\n  READ_ONLY_INTENT: 0x20\n};\n\nvar FLAGS_3 = {\n  CHANGE_PASSWORD_NO: 0x00,\n  CHANGE_PASSWORD_YES: 0x01,\n  BINARY_XML: 0x02,\n  SPAWN_USER_INSTANCE: 0x04,\n  UNKNOWN_COLLATION_HANDLING: 0x08\n};\n\nvar NTLMFlags = {\n  NTLM_NegotiateUnicode: 0x00000001,\n  NTLM_NegotiateOEM: 0x00000002,\n  NTLM_RequestTarget: 0x00000004,\n  NTLM_Unknown9: 0x00000008,\n  NTLM_NegotiateSign: 0x00000010,\n  NTLM_NegotiateSeal: 0x00000020,\n  NTLM_NegotiateDatagram: 0x00000040,\n  NTLM_NegotiateLanManagerKey: 0x00000080,\n  NTLM_Unknown8: 0x00000100,\n  NTLM_NegotiateNTLM: 0x00000200,\n  NTLM_NegotiateNTOnly: 0x00000400,\n  NTLM_Anonymous: 0x00000800,\n  NTLM_NegotiateOemDomainSupplied: 0x00001000,\n  NTLM_NegotiateOemWorkstationSupplied: 0x00002000,\n  NTLM_Unknown6: 0x00004000,\n  NTLM_NegotiateAlwaysSign: 0x00008000,\n  NTLM_TargetTypeDomain: 0x00010000,\n  NTLM_TargetTypeServer: 0x00020000,\n  NTLM_TargetTypeShare: 0x00040000,\n  NTLM_NegotiateExtendedSecurity: 0x00080000,\n  NTLM_NegotiateIdentify: 0x00100000,\n  NTLM_Unknown5: 0x00200000,\n  NTLM_RequestNonNTSessionKey: 0x00400000,\n  NTLM_NegotiateTargetInfo: 0x00800000,\n  NTLM_Unknown4: 0x01000000,\n  NTLM_NegotiateVersion: 0x02000000,\n  NTLM_Unknown3: 0x04000000,\n  NTLM_Unknown2: 0x08000000,\n  NTLM_Unknown1: 0x10000000,\n  NTLM_Negotiate128: 0x20000000,\n  NTLM_NegotiateKeyExchange: 0x40000000,\n  NTLM_Negotiate56: 0x80000000\n};\n\n/*\n  s2.2.6.3\n */\nmodule.exports = function () {\n  function Login7Payload(loginData) {\n    (0, _classCallCheck3.default)(this, Login7Payload);\n\n    this.loginData = loginData;\n\n    var lengthLength = 4;\n    var fixed = this.createFixedData();\n    var variable = this.createVariableData(lengthLength + fixed.length);\n    var length = lengthLength + fixed.length + variable.length;\n    var data = new WritableTrackingBuffer(300);\n    data.writeUInt32LE(length);\n    data.writeBuffer(fixed);\n    data.writeBuffer(variable);\n    this.data = data.data;\n  }\n\n  (0, _createClass3.default)(Login7Payload, [{\n    key: 'createFixedData',\n    value: function createFixedData() {\n      this.tdsVersion = versions[this.loginData.tdsVersion];\n      this.packetSize = this.loginData.packetSize;\n      this.clientProgVer = 0;\n      this.clientPid = process.pid;\n      this.connectionId = 0;\n      this.clientTimeZone = new Date().getTimezoneOffset();\n      this.clientLcid = 0x00000409;\n      this.flags1 = FLAGS_1.ENDIAN_LITTLE | FLAGS_1.CHARSET_ASCII | FLAGS_1.FLOAT_IEEE_754 | FLAGS_1.BCD_DUMPLOAD_OFF | FLAGS_1.USE_DB_OFF | FLAGS_1.SET_LANG_WARN_ON;\n      if (this.loginData.initDbFatal) {\n        this.flags1 |= FLAGS_1.INIT_DB_FATAL;\n      } else {\n        this.flags1 |= FLAGS_1.INIT_DB_WARN;\n      }\n      this.flags2 = FLAGS_2.INIT_LANG_WARN | FLAGS_2.ODBC_OFF | FLAGS_2.USER_NORMAL;\n      if (this.loginData.domain) {\n        this.flags2 |= FLAGS_2.INTEGRATED_SECURITY_ON;\n      } else {\n        this.flags2 |= FLAGS_2.INTEGRATED_SECURITY_OFF;\n      }\n      this.flags3 = FLAGS_3.CHANGE_PASSWORD_NO | FLAGS_3.UNKNOWN_COLLATION_HANDLING;\n      this.typeFlags = TYPE_FLAGS.SQL_DFLT | TYPE_FLAGS.OLEDB_OFF;\n      if (this.loginData.readOnlyIntent) {\n        this.typeFlags |= TYPE_FLAGS.READ_ONLY_INTENT;\n      } else {\n        this.typeFlags |= TYPE_FLAGS.READ_WRITE_INTENT;\n      }\n\n      var buffer = new WritableTrackingBuffer(100);\n      buffer.writeUInt32LE(this.tdsVersion);\n      buffer.writeUInt32LE(this.packetSize);\n      buffer.writeUInt32LE(this.clientProgVer);\n      buffer.writeUInt32LE(this.clientPid);\n      buffer.writeUInt32LE(this.connectionId);\n      buffer.writeUInt8(this.flags1);\n      buffer.writeUInt8(this.flags2);\n      buffer.writeUInt8(this.typeFlags);\n      buffer.writeUInt8(this.flags3);\n      buffer.writeInt32LE(this.clientTimeZone);\n      buffer.writeUInt32LE(this.clientLcid);\n      return buffer.data;\n    }\n  }, {\n    key: 'createVariableData',\n    value: function createVariableData(offset) {\n      this.variableLengthsLength = 9 * 4 + 6 + 3 * 4 + 4;\n      if (this.loginData.tdsVersion === '7_1') {\n        this.variableLengthsLength = 9 * 4 + 6 + 2 * 4;\n      }\n      var variableData = {\n        offsetsAndLengths: new WritableTrackingBuffer(200),\n        data: new WritableTrackingBuffer(200, 'ucs2'),\n        offset: offset + this.variableLengthsLength\n      };\n      this.hostname = os.hostname();\n      this.loginData = this.loginData || {};\n      this.loginData.appName = this.loginData.appName || 'Tedious';\n      this.libraryName = libraryName;\n      this.clientId = new Buffer([1, 2, 3, 4, 5, 6]);\n      if (!this.loginData.domain) {\n        this.sspi = '';\n        this.sspiLong = 0;\n      }\n      this.attachDbFile = '';\n      this.changePassword = '';\n      this.addVariableDataString(variableData, this.hostname);\n      this.addVariableDataString(variableData, this.loginData.userName);\n      this.addVariableDataBuffer(variableData, this.createPasswordBuffer());\n      this.addVariableDataString(variableData, this.loginData.appName);\n      this.addVariableDataString(variableData, this.loginData.serverName);\n      this.addVariableDataString(variableData, '');\n      this.addVariableDataString(variableData, this.libraryName);\n      this.addVariableDataString(variableData, this.loginData.language);\n      this.addVariableDataString(variableData, this.loginData.database);\n      variableData.offsetsAndLengths.writeBuffer(this.clientId);\n      if (this.loginData.domain) {\n        this.ntlmPacket = this.createNTLMRequest(this.loginData);\n        this.sspiLong = this.ntlmPacket.length;\n        variableData.offsetsAndLengths.writeUInt16LE(variableData.offset);\n        variableData.offsetsAndLengths.writeUInt16LE(this.ntlmPacket.length);\n        variableData.data.writeBuffer(this.ntlmPacket);\n        variableData.offset += this.ntlmPacket.length;\n      } else {\n        this.addVariableDataString(variableData, this.sspi);\n      }\n      this.addVariableDataString(variableData, this.attachDbFile);\n      if (this.loginData.tdsVersion > '7_1') {\n        this.addVariableDataString(variableData, this.changePassword);\n        variableData.offsetsAndLengths.writeUInt32LE(this.sspiLong);\n      }\n      return Buffer.concat([variableData.offsetsAndLengths.data, variableData.data.data]);\n    }\n  }, {\n    key: 'addVariableDataBuffer',\n    value: function addVariableDataBuffer(variableData, buffer) {\n      variableData.offsetsAndLengths.writeUInt16LE(variableData.offset);\n      variableData.offsetsAndLengths.writeUInt16LE(buffer.length / 2);\n      variableData.data.writeBuffer(buffer);\n      return variableData.offset += buffer.length;\n    }\n  }, {\n    key: 'addVariableDataString',\n    value: function addVariableDataString(variableData, value) {\n      value || (value = '');\n      variableData.offsetsAndLengths.writeUInt16LE(variableData.offset);\n      variableData.offsetsAndLengths.writeUInt16LE(value.length);\n      variableData.data.writeString(value);\n      return variableData.offset += value.length * 2;\n    }\n  }, {\n    key: 'createNTLMRequest',\n    value: function createNTLMRequest(options) {\n      var domain = escape(options.domain.toUpperCase());\n      var workstation = options.workstation ? escape(options.workstation.toUpperCase()) : '';\n      var protocol = 'NTLMSSP\\u0000';\n      var BODY_LENGTH = 40;\n      var bufferLength = BODY_LENGTH + domain.length;\n      var buffer = new WritableTrackingBuffer(bufferLength);\n\n      var type1flags = this.getNTLMFlags();\n      if (workstation === '') {\n        type1flags -= NTLMFlags.NTLM_NegotiateOemWorkstationSupplied;\n      }\n\n      buffer.writeString(protocol, 'utf8');\n      buffer.writeUInt32LE(1);\n      buffer.writeUInt32LE(type1flags);\n      buffer.writeUInt16LE(domain.length);\n      buffer.writeUInt16LE(domain.length);\n      buffer.writeUInt32LE(BODY_LENGTH + workstation.length);\n      buffer.writeUInt16LE(workstation.length);\n      buffer.writeUInt16LE(workstation.length);\n      buffer.writeUInt32LE(BODY_LENGTH);\n      buffer.writeUInt8(5);\n      buffer.writeUInt8(0);\n      buffer.writeUInt16LE(2195);\n      buffer.writeUInt8(0);\n      buffer.writeUInt8(0);\n      buffer.writeUInt8(0);\n      buffer.writeUInt8(15);\n      buffer.writeString(workstation, 'ascii');\n      buffer.writeString(domain, 'ascii');\n      return buffer.data;\n    }\n  }, {\n    key: 'createPasswordBuffer',\n    value: function createPasswordBuffer() {\n      var password = this.loginData.password || '';\n      password = new Buffer(password, 'ucs2');\n      for (var b = 0, len = password.length; b < len; b++) {\n        var byte = password[b];\n        var lowNibble = byte & 0x0f;\n        var highNibble = byte >> 4;\n        byte = lowNibble << 4 | highNibble;\n        byte = byte ^ 0xa5;\n        password[b] = byte;\n      }\n      return password;\n    }\n  }, {\n    key: 'getNTLMFlags',\n    value: function getNTLMFlags() {\n      return NTLMFlags.NTLM_NegotiateUnicode + NTLMFlags.NTLM_NegotiateOEM + NTLMFlags.NTLM_RequestTarget + NTLMFlags.NTLM_NegotiateNTLM + NTLMFlags.NTLM_NegotiateOemDomainSupplied + NTLMFlags.NTLM_NegotiateOemWorkstationSupplied + NTLMFlags.NTLM_NegotiateAlwaysSign + NTLMFlags.NTLM_NegotiateVersion + NTLMFlags.NTLM_NegotiateExtendedSecurity + NTLMFlags.NTLM_Negotiate128 + NTLMFlags.NTLM_Negotiate56;\n    }\n  }, {\n    key: 'toString',\n    value: function toString(indent) {\n      indent || (indent = '');\n      return indent + 'Login7 - ' + sprintf('TDS:0x%08X, PacketSize:0x%08X, ClientProgVer:0x%08X, ClientPID:0x%08X, ConnectionID:0x%08X', this.tdsVersion, this.packetSize, this.clientProgVer, this.clientPid, this.connectionId) + '\\n' + indent + '         ' + sprintf('Flags1:0x%02X, Flags2:0x%02X, TypeFlags:0x%02X, Flags3:0x%02X, ClientTimezone:%d, ClientLCID:0x%08X', this.flags1, this.flags2, this.typeFlags, this.flags3, this.clientTimeZone, this.clientLcid) + '\\n' + indent + '         ' + sprintf(\"Hostname:'%s', Username:'%s', Password:'%s', AppName:'%s', ServerName:'%s', LibraryName:'%s'\", this.hostname, this.loginData.userName, this.loginData.password, this.loginData.appName, this.loginData.serverName, libraryName) + '\\n' + indent + '         ' + sprintf(\"Language:'%s', Database:'%s', SSPI:'%s', AttachDbFile:'%s', ChangePassword:'%s'\", this.loginData.language, this.loginData.database, this.sspi, this.attachDbFile, this.changePassword);\n    }\n  }]);\n  return Login7Payload;\n}();","/home/travis/build/npmtest/node-npmtest-tedious/tedious/lib/library.js":"'use strict';\n\nmodule.exports.name = 'Tedious';","/home/travis/build/npmtest/node-npmtest-tedious/tedious/lib/tds-versions.js":"'use strict';\n\nvar versions = module.exports.versions = {\n  '7_1': 0x71000001,\n  '7_2': 0x72090002,\n  '7_3_A': 0x730A0003,\n  '7_3_B': 0x730B0003,\n  '7_4': 0x74000004\n};\n\nvar versionsByValue = module.exports.versionsByValue = {};\n\nfor (var name in versions) {\n  versionsByValue[versions[name]] = name;\n}","/home/travis/build/npmtest/node-npmtest-tedious/tedious/lib/ntlm-payload.js":"'use strict';\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar WritableTrackingBuffer = require('./tracking-buffer/writable-tracking-buffer');\nvar crypto = require('crypto');\nvar BigInteger = require('big-number').n;\n\nvar hex = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];\n\nmodule.exports = function () {\n  function NTLMResponsePayload(loginData) {\n    (0, _classCallCheck3.default)(this, NTLMResponsePayload);\n\n    this.data = this.createResponse(loginData);\n  }\n\n  (0, _createClass3.default)(NTLMResponsePayload, [{\n    key: 'toString',\n    value: function toString(indent) {\n      indent || (indent = '');\n      return indent + 'NTLM Auth';\n    }\n  }, {\n    key: 'createResponse',\n    value: function createResponse(challenge) {\n      var client_nonce = this.createClientNonce();\n      var lmv2len = 24;\n      var ntlmv2len = 16;\n      var domain = challenge.domain;\n      var username = challenge.userName;\n      var password = challenge.password;\n      var ntlmData = challenge.ntlmpacket;\n      var server_data = ntlmData.target;\n      var server_nonce = ntlmData.nonce;\n      var bufferLength = 64 + domain.length * 2 + username.length * 2 + lmv2len + ntlmv2len + 8 + 8 + 8 + 4 + server_data.length + 4;\n      var data = new WritableTrackingBuffer(bufferLength);\n      data.position = 0;\n      data.writeString('NTLMSSP\\u0000', 'utf8');\n      data.writeUInt32LE(0x03);\n      var baseIdx = 64;\n      var dnIdx = baseIdx;\n      var unIdx = dnIdx + domain.length * 2;\n      var l2Idx = unIdx + username.length * 2;\n      var ntIdx = l2Idx + lmv2len;\n      data.writeUInt16LE(lmv2len);\n      data.writeUInt16LE(lmv2len);\n      data.writeUInt32LE(l2Idx);\n      data.writeUInt16LE(ntlmv2len);\n      data.writeUInt16LE(ntlmv2len);\n      data.writeUInt32LE(ntIdx);\n      data.writeUInt16LE(domain.length * 2);\n      data.writeUInt16LE(domain.length * 2);\n      data.writeUInt32LE(dnIdx);\n      data.writeUInt16LE(username.length * 2);\n      data.writeUInt16LE(username.length * 2);\n      data.writeUInt32LE(unIdx);\n      data.writeUInt16LE(0);\n      data.writeUInt16LE(0);\n      data.writeUInt32LE(baseIdx);\n      data.writeUInt16LE(0);\n      data.writeUInt16LE(0);\n      data.writeUInt32LE(baseIdx);\n      data.writeUInt16LE(0x8201);\n      data.writeUInt16LE(0x08);\n      data.writeString(domain, 'ucs2');\n      data.writeString(username, 'ucs2');\n      var lmv2Data = this.lmv2Response(domain, username, password, server_nonce, client_nonce);\n      data.copyFrom(lmv2Data);\n      var genTime = new Date().getTime();\n      ntlmData = this.ntlmv2Response(domain, username, password, server_nonce, server_data, client_nonce, genTime);\n      data.copyFrom(ntlmData);\n      data.writeUInt32LE(0x0101);\n      data.writeUInt32LE(0x0000);\n      var timestamp = this.createTimestamp(genTime);\n      data.copyFrom(timestamp);\n      data.copyFrom(client_nonce);\n      data.writeUInt32LE(0x0000);\n      data.copyFrom(server_data);\n      data.writeUInt32LE(0x0000);\n      return data.data;\n    }\n  }, {\n    key: 'createClientNonce',\n    value: function createClientNonce() {\n      var client_nonce = new Buffer(8);\n      var nidx = 0;\n      while (nidx < 8) {\n        client_nonce.writeUInt8(Math.ceil(Math.random() * 255), nidx);\n        nidx++;\n      }\n      return client_nonce;\n    }\n  }, {\n    key: 'ntlmv2Response',\n    value: function ntlmv2Response(domain, user, password, serverNonce, targetInfo, clientNonce, mytime) {\n      var timestamp = this.createTimestamp(mytime);\n      var hash = this.ntv2Hash(domain, user, password);\n      var dataLength = 40 + targetInfo.length;\n      var data = new Buffer(dataLength);\n      serverNonce.copy(data, 0, 0, 8);\n      data.writeUInt32LE(0x101, 8);\n      data.writeUInt32LE(0x0, 12);\n      timestamp.copy(data, 16, 0, 8);\n      clientNonce.copy(data, 24, 0, 8);\n      data.writeUInt32LE(0x0, 32);\n      targetInfo.copy(data, 36, 0, targetInfo.length);\n      data.writeUInt32LE(0x0, 36 + targetInfo.length);\n      return this.hmacMD5(data, hash);\n    }\n  }, {\n    key: 'createTimestamp',\n    value: function createTimestamp(time) {\n      var tenthsOfAMicrosecond = new BigInteger(time).plus(11644473600).multiply(10000000);\n      var hexArray = [];\n\n      var pair = [];\n      while (tenthsOfAMicrosecond.val() !== '0') {\n        var idx = tenthsOfAMicrosecond.mod(16);\n        pair.unshift(hex[idx]);\n        if (pair.length === 2) {\n          hexArray.push(pair.join(''));\n          pair = [];\n        }\n      }\n\n      if (pair.length > 0) {\n        hexArray.push(pair[0] + '0');\n      }\n\n      return new Buffer(hexArray.join(''), 'hex');\n    }\n  }, {\n    key: 'lmv2Response',\n    value: function lmv2Response(domain, user, password, serverNonce, clientNonce) {\n      var hash = this.ntv2Hash(domain, user, password);\n      var data = new Buffer(serverNonce.length + clientNonce.length);\n\n      serverNonce.copy(data);\n      clientNonce.copy(data, serverNonce.length, 0, clientNonce.length);\n\n      var newhash = this.hmacMD5(data, hash);\n      var response = new Buffer(newhash.length + clientNonce.length);\n\n      newhash.copy(response);\n      clientNonce.copy(response, newhash.length, 0, clientNonce.length);\n\n      return response;\n    }\n  }, {\n    key: 'ntv2Hash',\n    value: function ntv2Hash(domain, user, password) {\n      var hash = this.ntHash(password);\n      var identity = new Buffer(user.toUpperCase() + domain.toUpperCase(), 'ucs2');\n      return this.hmacMD5(identity, hash);\n    }\n  }, {\n    key: 'ntHash',\n    value: function ntHash(text) {\n      var hash = new Buffer(21);\n      hash.fill(0);\n\n      var unicodeString = new Buffer(text, 'ucs2');\n      var md4 = crypto.createHash('md4').update(unicodeString).digest();\n      if (md4.copy) {\n        md4.copy(hash);\n      } else {\n        new Buffer(md4, 'ascii').copy(hash);\n      }\n      return hash;\n    }\n  }, {\n    key: 'hmacMD5',\n    value: function hmacMD5(data, key) {\n      var hmac = crypto.createHmac('MD5', key);\n      hmac.update(data);\n\n      var result = hmac.digest();\n      if (result.copy) {\n        return result;\n      } else {\n        return new Buffer(result, 'ascii').slice(0, 16);\n      }\n    }\n  }]);\n  return NTLMResponsePayload;\n}();","/home/travis/build/npmtest/node-npmtest-tedious/tedious/lib/request.js":"'use strict';\n\nvar _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = require('babel-runtime/helpers/inherits');\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar EventEmitter = require('events').EventEmitter;\nvar TYPES = require('./data-type').typeByName;\nvar RequestError = require('./errors').RequestError;\n\nmodule.exports = function (_EventEmitter) {\n  (0, _inherits3.default)(Request, _EventEmitter);\n\n  function Request(sqlTextOrProcedure, callback) {\n    (0, _classCallCheck3.default)(this, Request);\n\n    var _this = (0, _possibleConstructorReturn3.default)(this, (Request.__proto__ || (0, _getPrototypeOf2.default)(Request)).call(this));\n\n    _this.sqlTextOrProcedure = sqlTextOrProcedure;\n    _this.callback = callback;\n    _this.parameters = [];\n    _this.parametersByName = {};\n    _this.userCallback = _this.callback;\n    _this.callback = function () {\n      if (this.preparing) {\n        this.emit('prepared');\n        return this.preparing = false;\n      } else {\n        this.userCallback.apply(this, arguments);\n        return this.emit('requestCompleted');\n      }\n    };\n    return _this;\n  }\n\n  (0, _createClass3.default)(Request, [{\n    key: 'addParameter',\n    value: function addParameter(name, type, value, options) {\n      if (options == null) {\n        options = {};\n      }\n\n      var parameter = {\n        type: type,\n        name: name,\n        value: value,\n        output: options.output || (options.output = false),\n        length: options.length,\n        precision: options.precision,\n        scale: options.scale\n      };\n      this.parameters.push(parameter);\n      return this.parametersByName[name] = parameter;\n    }\n  }, {\n    key: 'addOutputParameter',\n    value: function addOutputParameter(name, type, value, options) {\n      if (options == null) {\n        options = {};\n      }\n      options.output = true;\n      return this.addParameter(name, type, value, options);\n    }\n  }, {\n    key: 'makeParamsParameter',\n    value: function makeParamsParameter(parameters) {\n      var paramsParameter = '';\n      for (var i = 0, len = parameters.length; i < len; i++) {\n        var parameter = parameters[i];\n        if (paramsParameter.length > 0) {\n          paramsParameter += ', ';\n        }\n        paramsParameter += '@' + parameter.name + ' ';\n        paramsParameter += parameter.type.declaration(parameter);\n        if (parameter.output) {\n          paramsParameter += ' OUTPUT';\n        }\n      }\n      return paramsParameter;\n    }\n  }, {\n    key: 'transformIntoExecuteSqlRpc',\n    value: function transformIntoExecuteSqlRpc() {\n      if (this.validateParameters()) {\n        return;\n      }\n\n      this.originalParameters = this.parameters;\n      this.parameters = [];\n      this.addParameter('statement', TYPES.NVarChar, this.sqlTextOrProcedure);\n      if (this.originalParameters.length) {\n        this.addParameter('params', TYPES.NVarChar, this.makeParamsParameter(this.originalParameters));\n      }\n\n      for (var i = 0, len = this.originalParameters.length; i < len; i++) {\n        var parameter = this.originalParameters[i];\n        this.parameters.push(parameter);\n      }\n      return this.sqlTextOrProcedure = 'sp_executesql';\n    }\n  }, {\n    key: 'transformIntoPrepareRpc',\n    value: function transformIntoPrepareRpc() {\n      var _this2 = this;\n\n      this.originalParameters = this.parameters;\n      this.parameters = [];\n      this.addOutputParameter('handle', TYPES.Int);\n      this.addParameter('params', TYPES.NVarChar, this.makeParamsParameter(this.originalParameters));\n      this.addParameter('stmt', TYPES.NVarChar, this.sqlTextOrProcedure);\n      this.sqlTextOrProcedure = 'sp_prepare';\n      this.preparing = true;\n      return this.on('returnValue', function (name, value) {\n        if (name === 'handle') {\n          return _this2.handle = value;\n        } else {\n          return _this2.error = RequestError('Tedious >Unexpected output parameter ' + name + ' from sp_prepare');\n        }\n      });\n    }\n  }, {\n    key: 'transformIntoUnprepareRpc',\n    value: function transformIntoUnprepareRpc() {\n      this.parameters = [];\n      this.addParameter('handle', TYPES.Int, this.handle);\n      return this.sqlTextOrProcedure = 'sp_unprepare';\n    }\n  }, {\n    key: 'transformIntoExecuteRpc',\n    value: function transformIntoExecuteRpc(parameters) {\n      this.parameters = [];\n      this.addParameter('handle', TYPES.Int, this.handle);\n\n      for (var i = 0, len = this.originalParameters.length; i < len; i++) {\n        var parameter = this.originalParameters[i];\n        parameter.value = parameters[parameter.name];\n        this.parameters.push(parameter);\n      }\n\n      if (this.validateParameters()) {\n        return;\n      }\n\n      return this.sqlTextOrProcedure = 'sp_execute';\n    }\n  }, {\n    key: 'validateParameters',\n    value: function validateParameters() {\n      for (var i = 0, len = this.parameters.length; i < len; i++) {\n        var parameter = this.parameters[i];\n        var value = parameter.type.validate(parameter.value);\n        if (value instanceof TypeError) {\n          return this.error = new RequestError('Validation failed for parameter \\'' + parameter.name + '\\'. ' + value.message, 'EPARAM');\n        }\n        parameter.value = value;\n      }\n      return null;\n    }\n  }]);\n  return Request;\n}(EventEmitter);","/home/travis/build/npmtest/node-npmtest-tedious/tedious/lib/data-type.js":"'use strict';\n\nvar guidParser = require('./guid-parser');\n\nvar NULL = (1 << 16) - 1;\nvar EPOCH_DATE = new Date(1900, 0, 1);\nvar UTC_EPOCH_DATE = new Date(Date.UTC(1900, 0, 1));\nvar YEAR_ONE = new Date(2000, 0, -730118);\nvar UTC_YEAR_ONE = Date.UTC(2000, 0, -730118);\nvar MAX = (1 << 16) - 1;\n\nvar typeByName = module.exports.typeByName = {};\n\nvar TYPE = module.exports.TYPE = {\n  0x1F: {\n    type: 'NULL',\n    name: 'Null'\n  },\n\n  0x30: {\n    type: 'INT1',\n    name: 'TinyInt',\n\n    declaration: function declaration() {\n      return 'tinyint';\n    },\n\n    writeTypeInfo: function writeTypeInfo(buffer) {\n      buffer.writeUInt8(typeByName.IntN.id);\n      return buffer.writeUInt8(1);\n    },\n\n    writeParameterData: function writeParameterData(buffer, parameter) {\n      if (parameter.value != null) {\n        buffer.writeUInt8(1);\n        return buffer.writeUInt8(parseInt(parameter.value));\n      } else {\n        return buffer.writeUInt8(0);\n      }\n    },\n\n    validate: function validate(value) {\n      if (value == null) {\n        return null;\n      }\n      value = parseInt(value);\n      if (isNaN(value)) {\n        return new TypeError('Invalid number.');\n      }\n      if (value < 0 || value > 255) {\n        return new TypeError('Value must be between 0 and 255.');\n      }\n      return value;\n    }\n  },\n\n  0x32: {\n    type: 'BIT',\n    name: 'Bit',\n\n    declaration: function declaration() {\n      return 'bit';\n    },\n\n    writeTypeInfo: function writeTypeInfo(buffer) {\n      buffer.writeUInt8(typeByName.BitN.id);\n      return buffer.writeUInt8(1);\n    },\n\n    writeParameterData: function writeParameterData(buffer, parameter) {\n      if (typeof parameter.value === 'undefined' || parameter.value === null) {\n        return buffer.writeUInt8(0);\n      } else {\n        buffer.writeUInt8(1);\n        return buffer.writeUInt8(parameter.value ? 1 : 0);\n      }\n    },\n\n    validate: function validate(value) {\n      if (value == null) {\n        return null;\n      }\n      if (value) {\n        return true;\n      } else {\n        return false;\n      }\n    }\n  },\n\n  0x34: {\n    type: 'INT2',\n    name: 'SmallInt',\n\n    declaration: function declaration() {\n      return 'smallint';\n    },\n\n    writeTypeInfo: function writeTypeInfo(buffer) {\n      buffer.writeUInt8(typeByName.IntN.id);\n      return buffer.writeUInt8(2);\n    },\n\n    writeParameterData: function writeParameterData(buffer, parameter) {\n      if (parameter.value != null) {\n        buffer.writeUInt8(2);\n        return buffer.writeInt16LE(parseInt(parameter.value));\n      } else {\n        return buffer.writeUInt8(0);\n      }\n    },\n\n    validate: function validate(value) {\n      if (value == null) {\n        return null;\n      }\n      value = parseInt(value);\n      if (isNaN(value)) {\n        return new TypeError('Invalid number.');\n      }\n      if (value < -32768 || value > 32767) {\n        return new TypeError('Value must be between -32768 and 32767.');\n      }\n      return value;\n    }\n  },\n\n  0x38: {\n    type: 'INT4',\n    name: 'Int',\n\n    declaration: function declaration() {\n      return 'int';\n    },\n\n    writeTypeInfo: function writeTypeInfo(buffer) {\n      buffer.writeUInt8(typeByName.IntN.id);\n      return buffer.writeUInt8(4);\n    },\n\n    writeParameterData: function writeParameterData(buffer, parameter) {\n      if (parameter.value != null) {\n        buffer.writeUInt8(4);\n        return buffer.writeInt32LE(parseInt(parameter.value));\n      } else {\n        return buffer.writeUInt8(0);\n      }\n    },\n\n    validate: function validate(value) {\n      if (value == null) {\n        return null;\n      }\n      value = parseInt(value);\n      if (isNaN(value)) {\n        return new TypeError('Invalid number.');\n      }\n      if (value < -2147483648 || value > 2147483647) {\n        return new TypeError('Value must be between -2147483648 and 2147483647.');\n      }\n      return value;\n    }\n  },\n\n  0x3A: {\n    type: 'DATETIM4',\n    name: 'SmallDateTime',\n\n    declaration: function declaration() {\n      return 'smalldatetime';\n    },\n\n    writeTypeInfo: function writeTypeInfo(buffer) {\n      buffer.writeUInt8(typeByName.DateTimeN.id);\n      return buffer.writeUInt8(4);\n    },\n\n    writeParameterData: function writeParameterData(buffer, parameter, options) {\n      if (parameter.value != null) {\n        var days = void 0,\n            dstDiff = void 0,\n            minutes = void 0;\n        if (options.useUTC) {\n          days = Math.floor((parameter.value.getTime() - UTC_EPOCH_DATE.getTime()) / (1000 * 60 * 60 * 24));\n          minutes = parameter.value.getUTCHours() * 60 + parameter.value.getUTCMinutes();\n        } else {\n          dstDiff = -(parameter.value.getTimezoneOffset() - EPOCH_DATE.getTimezoneOffset()) * 60 * 1000;\n          days = Math.floor((parameter.value.getTime() - EPOCH_DATE.getTime() + dstDiff) / (1000 * 60 * 60 * 24));\n          minutes = parameter.value.getHours() * 60 + parameter.value.getMinutes();\n        }\n\n        buffer.writeUInt8(4);\n        buffer.writeUInt16LE(days);\n\n        return buffer.writeUInt16LE(minutes);\n      } else {\n        return buffer.writeUInt8(0);\n      }\n    },\n\n    validate: function validate(value) {\n      if (value == null) {\n        return null;\n      }\n\n      if (!(value instanceof Date)) {\n        value = Date.parse(value);\n      }\n\n      if (isNaN(value)) {\n        return new TypeError('Invalid date.');\n      }\n\n      return value;\n    }\n  },\n\n  0x3B: {\n    type: 'FLT4',\n    name: 'Real',\n\n    declaration: function declaration() {\n      return 'real';\n    },\n\n    writeTypeInfo: function writeTypeInfo(buffer) {\n      buffer.writeUInt8(typeByName.FloatN.id);\n      return buffer.writeUInt8(4);\n    },\n\n    writeParameterData: function writeParameterData(buffer, parameter) {\n      if (parameter.value != null) {\n        buffer.writeUInt8(4);\n        return buffer.writeFloatLE(parseFloat(parameter.value));\n      } else {\n        return buffer.writeUInt8(0);\n      }\n    },\n\n    validate: function validate(value) {\n      if (value == null) {\n        return null;\n      }\n      value = parseFloat(value);\n      if (isNaN(value)) {\n        return new TypeError('Invalid number.');\n      }\n      return value;\n    }\n  },\n\n  0x3C: {\n    type: 'MONEY',\n    name: 'Money',\n\n    declaration: function declaration() {\n      return 'money';\n    },\n\n    writeTypeInfo: function writeTypeInfo(buffer) {\n      buffer.writeUInt8(typeByName.MoneyN.id);\n      return buffer.writeUInt8(8);\n    },\n\n    writeParameterData: function writeParameterData(buffer, parameter) {\n      if (parameter.value != null) {\n        buffer.writeUInt8(8);\n        return buffer.writeMoney(parameter.value * 10000);\n      } else {\n        return buffer.writeUInt8(0);\n      }\n    },\n\n    validate: function validate(value) {\n      if (value == null) {\n        return null;\n      }\n      value = parseFloat(value);\n      if (isNaN(value)) {\n        return new TypeError('Invalid number.');\n      }\n      return value;\n    }\n  },\n\n  0x3D: {\n    type: 'DATETIME',\n    name: 'DateTime',\n\n    declaration: function declaration() {\n      return 'datetime';\n    },\n\n    writeTypeInfo: function writeTypeInfo(buffer) {\n      buffer.writeUInt8(typeByName.DateTimeN.id);\n      return buffer.writeUInt8(8);\n    },\n\n    writeParameterData: function writeParameterData(buffer, parameter, options) {\n      if (parameter.value != null) {\n        var days = void 0,\n            dstDiff = void 0,\n            milliseconds = void 0,\n            seconds = void 0,\n            threeHundredthsOfSecond = void 0;\n        if (options.useUTC) {\n          days = Math.floor((parameter.value.getTime() - UTC_EPOCH_DATE.getTime()) / (1000 * 60 * 60 * 24));\n          seconds = parameter.value.getUTCHours() * 60 * 60;\n          seconds += parameter.value.getUTCMinutes() * 60;\n          seconds += parameter.value.getUTCSeconds();\n          milliseconds = seconds * 1000 + parameter.value.getUTCMilliseconds();\n        } else {\n          dstDiff = -(parameter.value.getTimezoneOffset() - EPOCH_DATE.getTimezoneOffset()) * 60 * 1000;\n          days = Math.floor((parameter.value.getTime() - EPOCH_DATE.getTime() + dstDiff) / (1000 * 60 * 60 * 24));\n          seconds = parameter.value.getHours() * 60 * 60;\n          seconds += parameter.value.getMinutes() * 60;\n          seconds += parameter.value.getSeconds();\n          milliseconds = seconds * 1000 + parameter.value.getMilliseconds();\n        }\n\n        threeHundredthsOfSecond = milliseconds / (3 + 1 / 3);\n        threeHundredthsOfSecond = Math.round(threeHundredthsOfSecond);\n\n        buffer.writeUInt8(8);\n        buffer.writeInt32LE(days);\n\n        return buffer.writeUInt32LE(threeHundredthsOfSecond);\n      } else {\n        return buffer.writeUInt8(0);\n      }\n    },\n\n    validate: function validate(value) {\n      if (value == null) {\n        return null;\n      }\n      if (!(value instanceof Date)) {\n        value = Date.parse(value);\n      }\n      if (isNaN(value)) {\n        return new TypeError('Invalid date.');\n      }\n      return value;\n    }\n  },\n\n  0x3E: {\n    type: 'FLT8',\n    name: 'Float',\n\n    declaration: function declaration() {\n      return 'float';\n    },\n\n    writeTypeInfo: function writeTypeInfo(buffer) {\n      buffer.writeUInt8(typeByName.FloatN.id);\n      return buffer.writeUInt8(8);\n    },\n\n    writeParameterData: function writeParameterData(buffer, parameter) {\n      if (parameter.value != null) {\n        buffer.writeUInt8(8);\n        return buffer.writeDoubleLE(parseFloat(parameter.value));\n      } else {\n        return buffer.writeUInt8(0);\n      }\n    },\n\n    validate: function validate(value) {\n      if (value == null) {\n        return null;\n      }\n      value = parseFloat(value);\n      if (isNaN(value)) {\n        return new TypeError('Invalid number.');\n      }\n      return value;\n    }\n  },\n\n  0x37: {\n    type: 'DECIMAL',\n    name: 'Decimal',\n    hasPrecision: true,\n    hasScale: true,\n\n    declaration: function declaration(parameter) {\n      return 'decimal(' + this.resolvePrecision(parameter) + ', ' + this.resolveScale(parameter) + ')';\n    },\n\n    resolvePrecision: function resolvePrecision(parameter) {\n      if (parameter.precision != null) {\n        return parameter.precision;\n      } else if (parameter.value === null) {\n        return 1;\n      } else {\n        return 18;\n      }\n    },\n\n    resolveScale: function resolveScale(parameter) {\n      if (parameter.scale != null) {\n        return parameter.scale;\n      } else {\n        return 0;\n      }\n    },\n\n    writeTypeInfo: function writeTypeInfo(buffer, parameter) {\n      buffer.writeUInt8(typeByName.DecimalN.id);\n      if (parameter.precision <= 9) {\n        buffer.writeUInt8(5);\n      } else if (parameter.precision <= 19) {\n        buffer.writeUInt8(9);\n      } else if (parameter.precision <= 28) {\n        buffer.writeUInt8(13);\n      } else {\n        buffer.writeUInt8(17);\n      }\n      buffer.writeUInt8(parameter.precision);\n      return buffer.writeUInt8(parameter.scale);\n    },\n\n    writeParameterData: function writeParameterData(buffer, parameter) {\n      if (parameter.value != null) {\n        var sign = parameter.value < 0 ? 0 : 1;\n        var value = Math.round(Math.abs(parameter.value * Math.pow(10, parameter.scale)));\n        if (parameter.precision <= 9) {\n          buffer.writeUInt8(5);\n          buffer.writeUInt8(sign);\n          return buffer.writeUInt32LE(value);\n        } else if (parameter.precision <= 19) {\n          buffer.writeUInt8(9);\n          buffer.writeUInt8(sign);\n          return buffer.writeUInt64LE(value);\n        } else if (parameter.precision <= 28) {\n          buffer.writeUInt8(13);\n          buffer.writeUInt8(sign);\n          buffer.writeUInt64LE(value);\n          return buffer.writeUInt32LE(0x00000000);\n        } else {\n          buffer.writeUInt8(17);\n          buffer.writeUInt8(sign);\n          buffer.writeUInt64LE(value);\n          buffer.writeUInt32LE(0x00000000);\n          return buffer.writeUInt32LE(0x00000000);\n        }\n      } else {\n        return buffer.writeUInt8(0);\n      }\n    },\n\n    validate: function validate(value) {\n      if (value == null) {\n        return null;\n      }\n      value = parseFloat(value);\n      if (isNaN(value)) {\n        return new TypeError('Invalid number.');\n      }\n      return value;\n    }\n  },\n\n  0x3F: {\n    type: 'NUMERIC',\n    name: 'Numeric',\n    hasPrecision: true,\n    hasScale: true,\n\n    declaration: function declaration(parameter) {\n      return 'numeric(' + this.resolvePrecision(parameter) + ', ' + this.resolveScale(parameter) + ')';\n    },\n\n    resolvePrecision: function resolvePrecision(parameter) {\n      if (parameter.precision != null) {\n        return parameter.precision;\n      } else if (parameter.value === null) {\n        return 1;\n      } else {\n        return 18;\n      }\n    },\n\n    resolveScale: function resolveScale(parameter) {\n      if (parameter.scale != null) {\n        return parameter.scale;\n      } else {\n        return 0;\n      }\n    },\n\n    writeTypeInfo: function writeTypeInfo(buffer, parameter) {\n      buffer.writeUInt8(typeByName.NumericN.id);\n      if (parameter.precision <= 9) {\n        buffer.writeUInt8(5);\n      } else if (parameter.precision <= 19) {\n        buffer.writeUInt8(9);\n      } else if (parameter.precision <= 28) {\n        buffer.writeUInt8(13);\n      } else {\n        buffer.writeUInt8(17);\n      }\n      buffer.writeUInt8(parameter.precision);\n      return buffer.writeUInt8(parameter.scale);\n    },\n\n    writeParameterData: function writeParameterData(buffer, parameter) {\n      if (parameter.value != null) {\n        var sign = parameter.value < 0 ? 0 : 1;\n        var value = Math.round(Math.abs(parameter.value * Math.pow(10, parameter.scale)));\n        if (parameter.precision <= 9) {\n          buffer.writeUInt8(5);\n          buffer.writeUInt8(sign);\n          return buffer.writeUInt32LE(value);\n        } else if (parameter.precision <= 19) {\n          buffer.writeUInt8(9);\n          buffer.writeUInt8(sign);\n          return buffer.writeUInt64LE(value);\n        } else if (parameter.precision <= 28) {\n          buffer.writeUInt8(13);\n          buffer.writeUInt8(sign);\n          buffer.writeUInt64LE(value);\n          return buffer.writeUInt32LE(0x00000000);\n        } else {\n          buffer.writeUInt8(17);\n          buffer.writeUInt8(sign);\n          buffer.writeUInt64LE(value);\n          buffer.writeUInt32LE(0x00000000);\n          return buffer.writeUInt32LE(0x00000000);\n        }\n      } else {\n        return buffer.writeUInt8(0);\n      }\n    },\n\n    validate: function validate(value) {\n      if (value == null) {\n        return null;\n      }\n      value = parseFloat(value);\n      if (isNaN(value)) {\n        return new TypeError('Invalid number.');\n      }\n      return value;\n    }\n  },\n\n  0x7A: {\n    type: 'MONEY4',\n    name: 'SmallMoney',\n\n    declaration: function declaration() {\n      return 'smallmoney';\n    },\n\n    writeTypeInfo: function writeTypeInfo(buffer) {\n      buffer.writeUInt8(typeByName.MoneyN.id);\n      return buffer.writeUInt8(4);\n    },\n\n    writeParameterData: function writeParameterData(buffer, parameter) {\n      if (parameter.value != null) {\n        buffer.writeUInt8(4);\n        return buffer.writeInt32LE(parameter.value * 10000);\n      } else {\n        return buffer.writeUInt8(0);\n      }\n    },\n\n    validate: function validate(value) {\n      if (value == null) {\n        return null;\n      }\n      value = parseFloat(value);\n      if (isNaN(value)) {\n        return new TypeError('Invalid number.');\n      }\n      if (value < -214748.3648 || value > 214748.3647) {\n        return new TypeError('Value must be between -214748.3648 and 214748.3647.');\n      }\n      return value;\n    }\n  },\n\n  0x7F: {\n    type: 'INT8',\n    name: 'BigInt',\n\n    declaration: function declaration() {\n      return 'bigint';\n    },\n\n    writeTypeInfo: function writeTypeInfo(buffer) {\n      buffer.writeUInt8(typeByName.IntN.id);\n      return buffer.writeUInt8(8);\n    },\n\n    writeParameterData: function writeParameterData(buffer, parameter) {\n      if (parameter.value != null) {\n        var val = typeof parameter.value !== 'number' ? parameter.value : parseInt(parameter.value);\n        buffer.writeUInt8(8);\n        return buffer.writeInt64LE(val);\n      } else {\n        return buffer.writeUInt8(0);\n      }\n    },\n\n    validate: function validate(value) {\n      if (value == null) {\n        return null;\n      }\n      if (isNaN(value)) {\n        return new TypeError('Invalid number.');\n      }\n      if (value < -9007199254740991 || value > 9007199254740991) {\n        // Number.MIN_SAFE_INTEGER = -9007199254740991\n        // Number.MAX_SAFE_INTEGER = 9007199254740991\n        // 9007199254740991 = (2**53) - 1\n        // Can't use Number.MIN_SAFE_INTEGER and Number.MAX_SAFE_INTEGER directly though\n        // as these constants are not available in node 0.10.\n        return new TypeError('Value must be between -9007199254740991 and 9007199254740991, inclusive.' + ' For bigger numbers, use VarChar type.');\n      }\n      return value;\n    }\n  },\n\n  0x22: {\n    type: 'IMAGE',\n    name: 'Image',\n    hasTableName: true,\n    hasTextPointerAndTimestamp: true,\n    dataLengthLength: 4,\n\n    declaration: function declaration() {\n      return 'image';\n    },\n\n    resolveLength: function resolveLength(parameter) {\n      if (parameter.value != null) {\n        return parameter.value.length;\n      } else {\n        return -1;\n      }\n    },\n\n    writeTypeInfo: function writeTypeInfo(buffer, parameter) {\n      buffer.writeUInt8(this.id);\n      return buffer.writeInt32LE(parameter.length);\n    },\n\n    writeParameterData: function writeParameterData(buffer, parameter) {\n      if (parameter.value != null) {\n        buffer.writeInt32LE(parameter.length);\n        return buffer.writeBuffer(parameter.value);\n      } else {\n        return buffer.writeInt32LE(parameter.length);\n      }\n    },\n\n    validate: function validate(value) {\n      if (value == null) {\n        return null;\n      }\n      if (!Buffer.isBuffer(value)) {\n        return new TypeError('Invalid buffer.');\n      }\n      return value;\n    }\n  },\n\n  0x23: {\n    type: 'TEXT',\n    name: 'Text',\n    hasCollation: true,\n    hasTableName: true,\n    hasTextPointerAndTimestamp: true,\n    dataLengthLength: 4,\n\n    declaration: function declaration() {\n      return 'text';\n    },\n\n    resolveLength: function resolveLength(parameter) {\n      if (parameter.value != null) {\n        return parameter.value.length;\n      } else {\n        return -1;\n      }\n    },\n\n    writeTypeInfo: function writeTypeInfo(buffer, parameter) {\n      buffer.writeUInt8(typeByName.Text.id);\n      return buffer.writeInt32LE(parameter.length);\n    },\n\n    writeParameterData: function writeParameterData(buffer, parameter) {\n      buffer.writeBuffer(new Buffer([0x00, 0x00, 0x00, 0x00, 0x00]));\n      if (parameter.value != null) {\n        buffer.writeInt32LE(parameter.length);\n        return buffer.writeString(parameter.value.toString(), 'ascii');\n      } else {\n        return buffer.writeInt32LE(parameter.length);\n      }\n    },\n\n    validate: function validate(value) {\n      if (value == null) {\n        return null;\n      }\n      if (typeof value !== 'string') {\n        if (typeof value.toString !== 'function') {\n          return TypeError('Invalid string.');\n        }\n        value = value.toString();\n      }\n      return value;\n    }\n  },\n\n  0x24: {\n    type: 'GUIDN',\n    name: 'UniqueIdentifierN',\n    aliases: ['UniqueIdentifier'],\n    dataLengthLength: 1,\n\n    declaration: function declaration() {\n      return 'uniqueidentifier';\n    },\n\n    resolveLength: function resolveLength() {\n      return 16;\n    },\n\n    writeTypeInfo: function writeTypeInfo(buffer) {\n      buffer.writeUInt8(typeByName.UniqueIdentifierN.id);\n      return buffer.writeUInt8(0x10);\n    },\n\n    writeParameterData: function writeParameterData(buffer, parameter) {\n      if (parameter.value != null) {\n        buffer.writeUInt8(0x10);\n        return buffer.writeBuffer(new Buffer(guidParser.guidToArray(parameter.value)));\n      } else {\n        return buffer.writeUInt8(0);\n      }\n    },\n\n    validate: function validate(value) {\n      if (value == null) {\n        return null;\n      }\n      if (typeof value !== 'string') {\n        if (typeof value.toString !== 'function') {\n          return TypeError('Invalid string.');\n        }\n        value = value.toString();\n      }\n      return value;\n    }\n  },\n\n  0x26: {\n    type: 'INTN',\n    name: 'IntN',\n    dataLengthLength: 1\n  },\n\n  0x63: {\n    type: 'NTEXT',\n    name: 'NText',\n    hasCollation: true,\n    hasTableName: true,\n    hasTextPointerAndTimestamp: true,\n    dataLengthLength: 4\n  },\n\n  0x68: {\n    type: 'BITN',\n    name: 'BitN',\n    dataLengthLength: 1\n  },\n  0x6A: {\n    type: 'DECIMALN',\n    name: 'DecimalN',\n    dataLengthLength: 1,\n    hasPrecision: true,\n    hasScale: true\n  },\n\n  0x6C: {\n    type: 'NUMERICN',\n    name: 'NumericN',\n    dataLengthLength: 1,\n    hasPrecision: true,\n    hasScale: true\n  },\n\n  0x6D: {\n    type: 'FLTN',\n    name: 'FloatN',\n    dataLengthLength: 1\n  },\n\n  0x6E: {\n    type: 'MONEYN',\n    name: 'MoneyN',\n    dataLengthLength: 1\n  },\n\n  0x6F: {\n    type: 'DATETIMN',\n    name: 'DateTimeN',\n    dataLengthLength: 1\n  },\n\n  0xA5: {\n    type: 'BIGVARBIN',\n    name: 'VarBinary',\n    dataLengthLength: 2,\n    maximumLength: 8000,\n\n    declaration: function declaration(parameter) {\n      var length = void 0;\n      if (parameter.length) {\n        length = parameter.length;\n      } else if (parameter.value != null) {\n        length = parameter.value.length || 1;\n      } else if (parameter.value === null && !parameter.output) {\n        length = 1;\n      } else {\n        length = this.maximumLength;\n      }\n\n      if (length <= this.maximumLength) {\n        return 'varbinary(' + length + ')';\n      } else {\n        return 'varbinary(max)';\n      }\n    },\n\n    resolveLength: function resolveLength(parameter) {\n      if (parameter.length != null) {\n        return parameter.length;\n      } else if (parameter.value != null) {\n        return parameter.value.length;\n      } else {\n        return this.maximumLength;\n      }\n    },\n\n    writeTypeInfo: function writeTypeInfo(buffer, parameter) {\n      buffer.writeUInt8(this.id);\n      if (parameter.length <= this.maximumLength) {\n        return buffer.writeUInt16LE(this.maximumLength);\n      } else {\n        return buffer.writeUInt16LE(MAX);\n      }\n    },\n\n    writeParameterData: function writeParameterData(buffer, parameter) {\n      if (parameter.value != null) {\n        if (parameter.length <= this.maximumLength) {\n          return buffer.writeUsVarbyte(parameter.value);\n        } else {\n          return buffer.writePLPBody(parameter.value);\n        }\n      } else {\n        if (parameter.length <= this.maximumLength) {\n          return buffer.writeUInt16LE(NULL);\n        } else {\n          buffer.writeUInt32LE(0xFFFFFFFF);\n          return buffer.writeUInt32LE(0xFFFFFFFF);\n        }\n      }\n    },\n\n    validate: function validate(value) {\n      if (value == null) {\n        return null;\n      }\n      if (!Buffer.isBuffer(value)) {\n        return new TypeError('Invalid buffer.');\n      }\n      return value;\n    }\n  },\n\n  0xA7: {\n    type: 'BIGVARCHR',\n    name: 'VarChar',\n    hasCollation: true,\n    dataLengthLength: 2,\n    maximumLength: 8000,\n\n    declaration: function declaration(parameter) {\n      var length = void 0;\n      if (parameter.length) {\n        length = parameter.length;\n      } else if (parameter.value != null) {\n        length = parameter.value.toString().length || 1;\n      } else if (parameter.value === null && !parameter.output) {\n        length = 1;\n      } else {\n        length = this.maximumLength;\n      }\n\n      if (length <= this.maximumLength) {\n        return 'varchar(' + length + ')';\n      } else {\n        return 'varchar(max)';\n      }\n    },\n\n    resolveLength: function resolveLength(parameter) {\n      if (parameter.length != null) {\n        return parameter.length;\n      } else if (parameter.value != null) {\n        if (Buffer.isBuffer(parameter.value)) {\n          return parameter.value.length || 1;\n        } else {\n          return parameter.value.toString().length || 1;\n        }\n      } else {\n        return this.maximumLength;\n      }\n    },\n\n    writeTypeInfo: function writeTypeInfo(buffer, parameter) {\n      buffer.writeUInt8(this.id);\n      if (parameter.length <= this.maximumLength) {\n        buffer.writeUInt16LE(this.maximumLength);\n      } else {\n        buffer.writeUInt16LE(MAX);\n      }\n      return buffer.writeBuffer(new Buffer([0x00, 0x00, 0x00, 0x00, 0x00]));\n    },\n\n    writeParameterData: function writeParameterData(buffer, parameter) {\n      if (parameter.value != null) {\n        if (parameter.length <= this.maximumLength) {\n          return buffer.writeUsVarbyte(parameter.value, 'ascii');\n        } else {\n          return buffer.writePLPBody(parameter.value, 'ascii');\n        }\n      } else {\n        if (parameter.length <= this.maximumLength) {\n          return buffer.writeUInt16LE(NULL);\n        } else {\n          buffer.writeUInt32LE(0xFFFFFFFF);\n          return buffer.writeUInt32LE(0xFFFFFFFF);\n        }\n      }\n    },\n\n    validate: function validate(value) {\n      if (value == null) {\n        return null;\n      }\n      if (typeof value !== 'string') {\n        if (typeof value.toString !== 'function') {\n          return TypeError('Invalid string.');\n        }\n        value = value.toString();\n      }\n      return value;\n    }\n  },\n\n  0xAD: {\n    type: 'BIGBinary',\n    name: 'Binary',\n    dataLengthLength: 2,\n    maximumLength: 8000,\n\n    declaration: function declaration(parameter) {\n      var length;\n      if (parameter.length) {\n        length = parameter.length;\n      } else if (parameter.value != null) {\n        length = parameter.value.length || 1;\n      } else if (parameter.value === null && !parameter.output) {\n        length = 1;\n      } else {\n        length = this.maximumLength;\n      }\n      return 'binary(' + length + ')';\n    },\n\n    resolveLength: function resolveLength(parameter) {\n      if (parameter.value != null) {\n        return parameter.value.length;\n      } else {\n        return this.maximumLength;\n      }\n    },\n\n    writeTypeInfo: function writeTypeInfo(buffer, parameter) {\n      buffer.writeUInt8(this.id);\n      return buffer.writeUInt16LE(parameter.length);\n    },\n\n    writeParameterData: function writeParameterData(buffer, parameter) {\n      if (parameter.value != null) {\n        buffer.writeUInt16LE(parameter.length);\n        return buffer.writeBuffer(parameter.value.slice(0, Math.min(parameter.length, this.maximumLength)));\n      } else {\n        return buffer.writeUInt16LE(NULL);\n      }\n    },\n\n    validate: function validate(value) {\n      if (value == null) {\n        return null;\n      }\n      if (!Buffer.isBuffer(value)) {\n        return new TypeError('Invalid buffer.');\n      }\n      return value;\n    }\n  },\n\n  0xAF: {\n    type: 'BIGCHAR',\n    name: 'Char',\n    hasCollation: true,\n    dataLengthLength: 2,\n    maximumLength: 8000,\n\n    declaration: function declaration(parameter) {\n      var length = void 0;\n      if (parameter.length) {\n        length = parameter.length;\n      } else if (parameter.value != null) {\n        length = parameter.value.toString().length || 1;\n      } else if (parameter.value === null && !parameter.output) {\n        length = 1;\n      } else {\n        length = this.maximumLength;\n      }\n\n      if (length < this.maximumLength) {\n        return 'char(' + length + ')';\n      } else {\n        return 'char(' + this.maximumLength + ')';\n      }\n    },\n\n    resolveLength: function resolveLength(parameter) {\n      if (parameter.length != null) {\n        return parameter.length;\n      } else if (parameter.value != null) {\n        if (Buffer.isBuffer(parameter.value)) {\n          return parameter.value.length || 1;\n        } else {\n          return parameter.value.toString().length || 1;\n        }\n      } else {\n        return this.maximumLength;\n      }\n    },\n\n    writeTypeInfo: function writeTypeInfo(buffer, parameter) {\n      buffer.writeUInt8(this.id);\n      buffer.writeUInt16LE(parameter.length);\n      return buffer.writeBuffer(new Buffer([0x00, 0x00, 0x00, 0x00, 0x00]));\n    },\n\n    writeParameterData: function writeParameterData(buffer, parameter) {\n      if (parameter.value != null) {\n        return buffer.writeUsVarbyte(parameter.value, 'ascii');\n      } else {\n        return buffer.writeUInt16LE(NULL);\n      }\n    },\n\n    validate: function validate(value) {\n      if (value == null) {\n        return null;\n      }\n      if (typeof value !== 'string') {\n        if (typeof value.toString !== 'function') {\n          return TypeError('Invalid string.');\n        }\n        value = value.toString();\n      }\n      return value;\n    }\n  },\n\n  0xE7: {\n    type: 'NVARCHAR',\n    name: 'NVarChar',\n    hasCollation: true,\n    dataLengthLength: 2,\n    maximumLength: 4000,\n\n    declaration: function declaration(parameter) {\n      var length = void 0;\n      if (parameter.length) {\n        length = parameter.length;\n      } else if (parameter.value != null) {\n        length = parameter.value.toString().length || 1;\n      } else if (parameter.value === null && !parameter.output) {\n        length = 1;\n      } else {\n        length = this.maximumLength;\n      }\n\n      if (length <= this.maximumLength) {\n        return 'nvarchar(' + length + ')';\n      } else {\n        return 'nvarchar(max)';\n      }\n    },\n\n    resolveLength: function resolveLength(parameter) {\n      if (parameter.length != null) {\n        return parameter.length;\n      } else if (parameter.value != null) {\n        if (Buffer.isBuffer(parameter.value)) {\n          return parameter.value.length / 2 || 1;\n        } else {\n          return parameter.value.toString().length || 1;\n        }\n      } else {\n        return this.maximumLength;\n      }\n    },\n\n    writeTypeInfo: function writeTypeInfo(buffer, parameter) {\n      buffer.writeUInt8(this.id);\n      if (parameter.length <= this.maximumLength) {\n        buffer.writeUInt16LE(parameter.length * 2);\n      } else {\n        buffer.writeUInt16LE(MAX);\n      }\n      return buffer.writeBuffer(new Buffer([0x00, 0x00, 0x00, 0x00, 0x00]));\n    },\n\n    writeParameterData: function writeParameterData(buffer, parameter) {\n      if (parameter.value != null) {\n        if (parameter.length <= this.maximumLength) {\n          return buffer.writeUsVarbyte(parameter.value, 'ucs2');\n        } else {\n          return buffer.writePLPBody(parameter.value, 'ucs2');\n        }\n      } else {\n        if (parameter.length <= this.maximumLength) {\n          return buffer.writeUInt16LE(NULL);\n        } else {\n          buffer.writeUInt32LE(0xFFFFFFFF);\n          return buffer.writeUInt32LE(0xFFFFFFFF);\n        }\n      }\n    },\n\n    validate: function validate(value) {\n      if (value == null) {\n        return null;\n      }\n      if (typeof value !== 'string') {\n        if (typeof value.toString !== 'function') {\n          return TypeError('Invalid string.');\n        }\n        value = value.toString();\n      }\n      return value;\n    }\n  },\n\n  0xEF: {\n    type: 'NCHAR',\n    name: 'NChar',\n    hasCollation: true,\n    dataLengthLength: 2,\n    maximumLength: 4000,\n\n    declaration: function declaration(parameter) {\n      var length = void 0;\n      if (parameter.length) {\n        length = parameter.length;\n      } else if (parameter.value != null) {\n        length = parameter.value.toString().length || 1;\n      } else if (parameter.value === null && !parameter.output) {\n        length = 1;\n      } else {\n        length = this.maximumLength;\n      }\n\n      if (length < this.maximumLength) {\n        return 'nchar(' + length + ')';\n      } else {\n        return 'nchar(' + this.maximumLength + ')';\n      }\n    },\n\n    resolveLength: function resolveLength(parameter) {\n      if (parameter.length != null) {\n        return parameter.length;\n      } else if (parameter.value != null) {\n        if (Buffer.isBuffer(parameter.value)) {\n          return parameter.value.length / 2 || 1;\n        } else {\n          return parameter.value.toString().length || 1;\n        }\n      } else {\n        return this.maximumLength;\n      }\n    },\n\n    writeTypeInfo: function writeTypeInfo(buffer, parameter) {\n      buffer.writeUInt8(this.id);\n      buffer.writeUInt16LE(parameter.length * 2);\n      return buffer.writeBuffer(new Buffer([0x00, 0x00, 0x00, 0x00, 0x00]));\n    },\n\n    writeParameterData: function writeParameterData(buffer, parameter) {\n      if (parameter.value != null) {\n        return buffer.writeUsVarbyte(parameter.value, 'ucs2');\n      } else {\n        return buffer.writeUInt16LE(NULL);\n      }\n    },\n\n    validate: function validate(value) {\n      if (value == null) {\n        return null;\n      }\n      if (typeof value !== 'string') {\n        if (typeof value.toString !== 'function') {\n          return TypeError('Invalid string.');\n        }\n        value = value.toString();\n      }\n      return value;\n    }\n  },\n\n  0xF1: {\n    type: 'XML',\n    name: 'Xml',\n    hasSchemaPresent: true\n  },\n\n  0x29: {\n    type: 'TIMEN',\n    name: 'TimeN',\n    aliases: ['Time'],\n    hasScale: true,\n    dataLengthLength: 1,\n\n    dataLengthFromScale: function dataLengthFromScale(scale) {\n      switch (scale) {\n        case 0:\n        case 1:\n        case 2:\n          return 3;\n        case 3:\n        case 4:\n          return 4;\n        case 5:\n        case 6:\n        case 7:\n          return 5;\n      }\n    },\n\n    declaration: function declaration(parameter) {\n      return 'time(' + this.resolveScale(parameter) + ')';\n    },\n\n    resolveScale: function resolveScale(parameter) {\n      if (parameter.scale != null) {\n        return parameter.scale;\n      } else if (parameter.value === null) {\n        return 0;\n      } else {\n        return 7;\n      }\n    },\n\n    writeTypeInfo: function writeTypeInfo(buffer, parameter) {\n      buffer.writeUInt8(this.id);\n      return buffer.writeUInt8(parameter.scale);\n    },\n\n    writeParameterData: function writeParameterData(buffer, parameter, options) {\n      if (parameter.value != null) {\n        var ref = void 0,\n            time = new Date(+parameter.value);\n        if (options.useUTC) {\n          time = ((time.getUTCHours() * 60 + time.getUTCMinutes()) * 60 + time.getUTCSeconds()) * 1000 + time.getUTCMilliseconds();\n        } else {\n          time = ((time.getHours() * 60 + time.getMinutes()) * 60 + time.getSeconds()) * 1000 + time.getMilliseconds();\n        }\n        time = (time / 1000 + ((ref = parameter.value.nanosecondDelta) != null ? ref : 0)) * Math.pow(10, parameter.scale);\n        switch (parameter.scale) {\n          case 0:\n          case 1:\n          case 2:\n            buffer.writeUInt8(3);\n            return buffer.writeUInt24LE(time);\n          case 3:\n          case 4:\n            buffer.writeUInt8(4);\n            return buffer.writeUInt32LE(time);\n          case 5:\n          case 6:\n          case 7:\n            buffer.writeUInt8(5);\n            return buffer.writeUInt40LE(time);\n        }\n      } else {\n        return buffer.writeUInt8(0);\n      }\n    },\n\n    validate: function validate(value) {\n      if (value == null) {\n        return null;\n      }\n      if (value instanceof Date) {\n        return value;\n      }\n      value = Date.parse(value);\n      if (isNaN(value)) {\n        return new TypeError('Invalid time.');\n      }\n      return value;\n    }\n  },\n\n  0x28: {\n    type: 'DATEN',\n    name: 'DateN',\n    aliases: ['Date'],\n    dataLengthLength: 1,\n    fixedDataLength: 3,\n\n    declaration: function declaration() {\n      return 'date';\n    },\n\n    writeTypeInfo: function writeTypeInfo(buffer) {\n      return buffer.writeUInt8(this.id);\n    },\n\n    writeParameterData: function writeParameterData(buffer, parameter, options) {\n      if (parameter.value != null) {\n        buffer.writeUInt8(3);\n        if (options.useUTC) {\n          return buffer.writeUInt24LE(Math.floor((+parameter.value - UTC_YEAR_ONE) / 86400000));\n        } else {\n          var dstDiff = -(parameter.value.getTimezoneOffset() - YEAR_ONE.getTimezoneOffset()) * 60 * 1000;\n          return buffer.writeUInt24LE(Math.floor((+parameter.value - YEAR_ONE + dstDiff) / 86400000));\n        }\n      } else {\n        return buffer.writeUInt8(0);\n      }\n    },\n\n    validate: function validate(value) {\n      if (value == null) {\n        return null;\n      }\n      if (!(value instanceof Date)) {\n        value = Date.parse(value);\n      }\n      if (isNaN(value)) {\n        return new TypeError('Invalid date.');\n      }\n      return value;\n    }\n  },\n\n  0x2A: {\n    type: 'DATETIME2N',\n    name: 'DateTime2N',\n    aliases: ['DateTime2'],\n    hasScale: true,\n    dataLengthLength: 1,\n\n    dataLengthFromScale: function dataLengthFromScale(scale) {\n      switch (scale) {\n        case 0:\n        case 1:\n        case 2:\n          return 3;\n        case 3:\n        case 4:\n          return 4;\n        case 5:\n        case 6:\n        case 7:\n          return 5;\n      }\n    },\n\n    declaration: function declaration(parameter) {\n      return 'datetime2(' + this.resolveScale(parameter) + ')';\n    },\n\n    resolveScale: function resolveScale(parameter) {\n      if (parameter.scale != null) {\n        return parameter.scale;\n      } else if (parameter.value === null) {\n        return 0;\n      } else {\n        return 7;\n      }\n    },\n\n    writeTypeInfo: function writeTypeInfo(buffer, parameter) {\n      buffer.writeUInt8(this.id);\n      return buffer.writeUInt8(parameter.scale);\n    },\n\n    writeParameterData: function writeParameterData(buffer, parameter, options) {\n      if (parameter.value != null) {\n        var ref = void 0,\n            time = new Date(+parameter.value);\n        if (options.useUTC) {\n          time = ((time.getUTCHours() * 60 + time.getUTCMinutes()) * 60 + time.getUTCSeconds()) * 1000 + time.getUTCMilliseconds();\n        } else {\n          time = ((time.getHours() * 60 + time.getMinutes()) * 60 + time.getSeconds()) * 1000 + time.getMilliseconds();\n        }\n        time = (time / 1000 + ((ref = parameter.value.nanosecondDelta) != null ? ref : 0)) * Math.pow(10, parameter.scale);\n        switch (parameter.scale) {\n          case 0:\n          case 1:\n          case 2:\n            buffer.writeUInt8(6);\n            buffer.writeUInt24LE(time);\n            break;\n          case 3:\n          case 4:\n            buffer.writeUInt8(7);\n            buffer.writeUInt32LE(time);\n            break;\n          case 5:\n          case 6:\n          case 7:\n            buffer.writeUInt8(8);\n            buffer.writeUInt40LE(time);\n        }\n        if (options.useUTC) {\n          return buffer.writeUInt24LE(Math.floor((+parameter.value - UTC_YEAR_ONE) / 86400000));\n        } else {\n          var dstDiff = -(parameter.value.getTimezoneOffset() - YEAR_ONE.getTimezoneOffset()) * 60 * 1000;\n          return buffer.writeUInt24LE(Math.floor((+parameter.value - YEAR_ONE + dstDiff) / 86400000));\n        }\n      } else {\n        return buffer.writeUInt8(0);\n      }\n    },\n\n    validate: function validate(value) {\n      if (value == null) {\n        return null;\n      }\n      if (!(value instanceof Date)) {\n        value = Date.parse(value);\n      }\n      if (isNaN(value)) {\n        return new TypeError('Invalid date.');\n      }\n      return value;\n    }\n  },\n\n  0x2B: {\n    type: 'DATETIMEOFFSETN',\n    name: 'DateTimeOffsetN',\n    aliases: ['DateTimeOffset'],\n    hasScale: true,\n    dataLengthLength: 1,\n    dataLengthFromScale: function dataLengthFromScale(scale) {\n      switch (scale) {\n        case 0:\n        case 1:\n        case 2:\n          return 3;\n        case 3:\n        case 4:\n          return 4;\n        case 5:\n        case 6:\n        case 7:\n          return 5;\n      }\n    },\n    declaration: function declaration(parameter) {\n      return 'datetimeoffset(' + this.resolveScale(parameter) + ')';\n    },\n    resolveScale: function resolveScale(parameter) {\n      if (parameter.scale != null) {\n        return parameter.scale;\n      } else if (parameter.value === null) {\n        return 0;\n      } else {\n        return 7;\n      }\n    },\n    writeTypeInfo: function writeTypeInfo(buffer, parameter) {\n      buffer.writeUInt8(this.id);\n      return buffer.writeUInt8(parameter.scale);\n    },\n    writeParameterData: function writeParameterData(buffer, parameter) {\n      if (parameter.value != null) {\n        var ref = void 0,\n            time = new Date(+parameter.value);\n        time.setUTCFullYear(1970);\n        time.setUTCMonth(0);\n        time.setUTCDate(1);\n        time = (+time / 1000 + ((ref = parameter.value.nanosecondDelta) != null ? ref : 0)) * Math.pow(10, parameter.scale);\n        var offset = -parameter.value.getTimezoneOffset();\n        switch (parameter.scale) {\n          case 0:\n          case 1:\n          case 2:\n            buffer.writeUInt8(8);\n            buffer.writeUInt24LE(time);\n            break;\n          case 3:\n          case 4:\n            buffer.writeUInt8(9);\n            buffer.writeUInt32LE(time);\n            break;\n          case 5:\n          case 6:\n          case 7:\n            buffer.writeUInt8(10);\n            buffer.writeUInt40LE(time);\n        }\n        buffer.writeUInt24LE(Math.floor((+parameter.value - UTC_YEAR_ONE) / 86400000));\n        return buffer.writeInt16LE(offset);\n      } else {\n        return buffer.writeUInt8(0);\n      }\n    },\n    validate: function validate(value) {\n      if (value == null) {\n        return null;\n      }\n      if (!(value instanceof Date)) {\n        value = Date.parse(value);\n      }\n      if (isNaN(value)) {\n        return new TypeError('Invalid date.');\n      }\n      return value;\n    }\n  },\n\n  0xF0: {\n    type: 'UDTTYPE',\n    name: 'UDT',\n    hasUDTInfo: true\n  },\n\n  0xF3: {\n    type: 'TVPTYPE',\n    name: 'TVP',\n\n    declaration: function declaration(parameter) {\n      return parameter.value.name + ' readonly';\n    },\n\n    writeTypeInfo: function writeTypeInfo(buffer, parameter) {\n      var ref = void 0,\n          ref1 = void 0,\n          ref2 = void 0,\n          ref3 = void 0;\n      buffer.writeUInt8(this.id);\n      buffer.writeBVarchar('');\n      buffer.writeBVarchar((ref = (ref1 = parameter.value) != null ? ref1.schema : undefined) != null ? ref : '');\n      buffer.writeBVarchar((ref2 = (ref3 = parameter.value) != null ? ref3.name : undefined) != null ? ref2 : '');\n    },\n\n    writeParameterData: function writeParameterData(buffer, parameter, options) {\n      if (parameter.value == null) {\n        buffer.writeUInt16LE(0xFFFF);\n        buffer.writeUInt8(0x00);\n        buffer.writeUInt8(0x00);\n        return;\n      }\n\n      buffer.writeUInt16LE(parameter.value.columns.length);\n\n      var ref = parameter.value.columns;\n      for (var i = 0, len = ref.length; i < len; i++) {\n        var column = ref[i];\n        buffer.writeUInt32LE(0x00000000);\n        buffer.writeUInt16LE(0x0000);\n        column.type.writeTypeInfo(buffer, column);\n        buffer.writeBVarchar('');\n      }\n\n      buffer.writeUInt8(0x00);\n\n      var ref1 = parameter.value.rows;\n      for (var j = 0, len1 = ref1.length; j < len1; j++) {\n        var row = ref1[j];\n\n        buffer.writeUInt8(0x01);\n\n        for (var k = 0, len2 = row.length; k < len2; k++) {\n          var value = row[k];\n          var param = {\n            value: value,\n            length: parameter.value.columns[k].length,\n            scale: parameter.value.columns[k].scale,\n            precision: parameter.value.columns[k].precision\n          };\n          parameter.value.columns[k].type.writeParameterData(buffer, param, options);\n        }\n      }\n\n      buffer.writeUInt8(0x00);\n    },\n    validate: function validate(value) {\n      if (value == null) {\n        return null;\n      }\n\n      if (typeof value !== 'object') {\n        return new TypeError('Invalid table.');\n      }\n\n      if (!Array.isArray(value.columns)) {\n        return new TypeError('Invalid table.');\n      }\n\n      if (!Array.isArray(value.rows)) {\n        return new TypeError('Invalid table.');\n      }\n\n      return value;\n    }\n  },\n\n  0x62: {\n    type: 'SSVARIANTTYPE',\n    name: 'Variant',\n    dataLengthLength: 4,\n\n    declaration: function declaration(parameter) {\n      return 'sql_variant';\n    }\n  }\n};\n\n/*\n  CHARTYPE:             0x2F  # Char (legacy support)\n  VARCHARTYPE:          0x27  # VarChar (legacy support)\n  BINARYTYPE:           0x2D  # Binary (legacy support)\n  VARBINARYTYPE:        0x25  # VarBinary (legacy support)\n\n  SSVARIANTTYPE:        0x62  # Sql_Variant (introduced in TDS 7.2)\n */\n\nfor (var id in TYPE) {\n  var type = TYPE[id];\n  type.id = parseInt(id, 10);\n  typeByName[type.name] = type;\n  if (type.aliases != null && type.aliases instanceof Array) {\n    var ref = type.aliases;\n    var len = ref.length;\n\n    for (var i = 0; i < len; i++) {\n      var alias = ref[i];\n      if (!typeByName[alias]) {\n        typeByName[alias] = type;\n      }\n    }\n  }\n}","/home/travis/build/npmtest/node-npmtest-tedious/tedious/lib/guid-parser.js":"'use strict';\n\nvar MAP = ['00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '0A', '0B', '0C', '0D', '0E', '0F', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '1A', '1B', '1C', '1D', '1E', '1F', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '2A', '2B', '2C', '2D', '2E', '2F', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '3A', '3B', '3C', '3D', '3E', '3F', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '4A', '4B', '4C', '4D', '4E', '4F', '50', '51', '52', '53', '54', '55', '56', '57', '58', '59', '5A', '5B', '5C', '5D', '5E', '5F', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '6A', '6B', '6C', '6D', '6E', '6F', '70', '71', '72', '73', '74', '75', '76', '77', '78', '79', '7A', '7B', '7C', '7D', '7E', '7F', '80', '81', '82', '83', '84', '85', '86', '87', '88', '89', '8A', '8B', '8C', '8D', '8E', '8F', '90', '91', '92', '93', '94', '95', '96', '97', '98', '99', '9A', '9B', '9C', '9D', '9E', '9F', 'A0', 'A1', 'A2', 'A3', 'A4', 'A5', 'A6', 'A7', 'A8', 'A9', 'AA', 'AB', 'AC', 'AD', 'AE', 'AF', 'B0', 'B1', 'B2', 'B3', 'B4', 'B5', 'B6', 'B7', 'B8', 'B9', 'BA', 'BB', 'BC', 'BD', 'BE', 'BF', 'C0', 'C1', 'C2', 'C3', 'C4', 'C5', 'C6', 'C7', 'C8', 'C9', 'CA', 'CB', 'CC', 'CD', 'CE', 'CF', 'D0', 'D1', 'D2', 'D3', 'D4', 'D5', 'D6', 'D7', 'D8', 'D9', 'DA', 'DB', 'DC', 'DD', 'DE', 'DF', 'E0', 'E1', 'E2', 'E3', 'E4', 'E5', 'E6', 'E7', 'E8', 'E9', 'EA', 'EB', 'EC', 'ED', 'EE', 'EF', 'F0', 'F1', 'F2', 'F3', 'F4', 'F5', 'F6', 'F7', 'F8', 'F9', 'FA', 'FB', 'FC', 'FD', 'FE', 'FF'];\n\nmodule.exports.arrayToGuid = arrayToGuid;\nfunction arrayToGuid(array) {\n  return MAP[array[3]] + MAP[array[2]] + MAP[array[1]] + MAP[array[0]] + '-' + MAP[array[5]] + MAP[array[4]] + '-' + MAP[array[7]] + MAP[array[6]] + '-' + MAP[array[8]] + MAP[array[9]] + '-' + MAP[array[10]] + MAP[array[11]] + MAP[array[12]] + MAP[array[13]] + MAP[array[14]] + MAP[array[15]];\n}\n\nvar CHARCODEMAP = {};\n\nvar hexDigits = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f', 'A', 'B', 'C', 'D', 'E', 'F'].map(function (d) {\n  return d.charCodeAt(0);\n});\n\nfor (var i = 0; i < hexDigits.length; i++) {\n  var map = CHARCODEMAP[hexDigits[i]] = {};\n  for (var j = 0; j < hexDigits.length; j++) {\n    var hex = String.fromCharCode(hexDigits[i], hexDigits[j]);\n    var value = parseInt(hex, 16);\n    map[hexDigits[j]] = value;\n  }\n}\n\nmodule.exports.guidToArray = guidToArray;\nfunction guidToArray(guid) {\n  return [CHARCODEMAP[guid.charCodeAt(6)][guid.charCodeAt(7)], CHARCODEMAP[guid.charCodeAt(4)][guid.charCodeAt(5)], CHARCODEMAP[guid.charCodeAt(2)][guid.charCodeAt(3)], CHARCODEMAP[guid.charCodeAt(0)][guid.charCodeAt(1)], CHARCODEMAP[guid.charCodeAt(11)][guid.charCodeAt(12)], CHARCODEMAP[guid.charCodeAt(9)][guid.charCodeAt(10)], CHARCODEMAP[guid.charCodeAt(16)][guid.charCodeAt(17)], CHARCODEMAP[guid.charCodeAt(14)][guid.charCodeAt(15)], CHARCODEMAP[guid.charCodeAt(19)][guid.charCodeAt(20)], CHARCODEMAP[guid.charCodeAt(21)][guid.charCodeAt(22)], CHARCODEMAP[guid.charCodeAt(24)][guid.charCodeAt(25)], CHARCODEMAP[guid.charCodeAt(26)][guid.charCodeAt(27)], CHARCODEMAP[guid.charCodeAt(28)][guid.charCodeAt(29)], CHARCODEMAP[guid.charCodeAt(30)][guid.charCodeAt(31)], CHARCODEMAP[guid.charCodeAt(32)][guid.charCodeAt(33)], CHARCODEMAP[guid.charCodeAt(34)][guid.charCodeAt(35)]];\n}","/home/travis/build/npmtest/node-npmtest-tedious/tedious/lib/errors.js":"'use strict';\n\nvar util = require('util');\n\nmodule.exports.ConnectionError = ConnectionError;\nfunction ConnectionError(message, code) {\n  if (!(this instanceof ConnectionError)) {\n    if (message instanceof ConnectionError) {\n      return message;\n    }\n\n    return new ConnectionError(message, code);\n  }\n\n  Error.call(this);\n\n  this.message = message;\n  this.code = code;\n\n  Error.captureStackTrace(this, this.constructor);\n}\n\nutil.inherits(ConnectionError, Error);\n\nConnectionError.prototype.name = 'ConnectionError';\n\nmodule.exports.RequestError = RequestError;\nfunction RequestError(message, code) {\n  if (!(this instanceof RequestError)) {\n    if (message instanceof RequestError) {\n      return message;\n    }\n\n    return new RequestError(message, code);\n  }\n\n  Error.call(this);\n\n  this.message = message;\n  this.code = code;\n\n  Error.captureStackTrace(this, this.constructor);\n}\n\nutil.inherits(RequestError, Error);\n\nRequestError.prototype.name = 'RequestError';","/home/travis/build/npmtest/node-npmtest-tedious/tedious/lib/rpcrequest-payload.js":"'use strict';\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar WritableTrackingBuffer = require('./tracking-buffer/tracking-buffer').WritableTrackingBuffer;\nvar writeAllHeaders = require('./all-headers').writeToTrackingBuffer;\n\n// const OPTION = {\n//   WITH_RECOMPILE: 0x01,\n//   NO_METADATA: 0x02,\n//   REUSE_METADATA: 0x04\n// };\n\nvar STATUS = {\n  BY_REF_VALUE: 0x01,\n  DEFAULT_VALUE: 0x02\n};\n\n/*\n  s2.2.6.5\n */\nmodule.exports = function () {\n  function RpcRequestPayload(request, txnDescriptor, options) {\n    (0, _classCallCheck3.default)(this, RpcRequestPayload);\n\n    this.request = request;\n    this.procedure = this.request.sqlTextOrProcedure;\n\n    var buffer = new WritableTrackingBuffer(500);\n    if (options.tdsVersion >= '7_2') {\n      var outstandingRequestCount = 1;\n      writeAllHeaders(buffer, txnDescriptor, outstandingRequestCount);\n    }\n\n    if (typeof this.procedure === 'string') {\n      buffer.writeUsVarchar(this.procedure);\n    } else {\n      buffer.writeUShort(0xFFFF);\n      buffer.writeUShort(this.procedure);\n    }\n\n    var optionFlags = 0;\n    buffer.writeUInt16LE(optionFlags);\n\n    var parameters = this.request.parameters;\n    for (var i = 0, len = parameters.length; i < len; i++) {\n      var parameter = parameters[i];\n      buffer.writeBVarchar('@' + parameter.name);\n\n      var statusFlags = 0;\n      if (parameter.output) {\n        statusFlags |= STATUS.BY_REF_VALUE;\n      }\n      buffer.writeUInt8(statusFlags);\n\n      var param = {\n        value: parameter.value\n      };\n\n      var type = parameter.type;\n\n      if ((type.id & 0x30) === 0x20) {\n        if (parameter.length) {\n          param.length = parameter.length;\n        } else if (type.resolveLength) {\n          param.length = type.resolveLength(parameter);\n        }\n      }\n\n      if (type.hasPrecision) {\n        if (parameter.precision) {\n          param.precision = parameter.precision;\n        } else if (type.resolvePrecision) {\n          param.precision = type.resolvePrecision(parameter);\n        }\n      }\n\n      if (type.hasScale) {\n        if (parameter.scale) {\n          param.scale = parameter.scale;\n        } else if (type.resolveScale) {\n          param.scale = type.resolveScale(parameter);\n        }\n      }\n\n      type.writeTypeInfo(buffer, param, options);\n      type.writeParameterData(buffer, param, options);\n    }\n\n    this.data = buffer.data;\n  }\n\n  (0, _createClass3.default)(RpcRequestPayload, [{\n    key: 'toString',\n    value: function toString(indent) {\n      indent || (indent = '');\n      return indent + ('RPC Request - ' + this.procedure);\n    }\n  }]);\n  return RpcRequestPayload;\n}();","/home/travis/build/npmtest/node-npmtest-tedious/tedious/lib/all-headers.js":"'use strict';\n\nvar TYPE = {\n  QUERY_NOTIFICATIONS: 1,\n  TXN_DESCRIPTOR: 2,\n  TRACE_ACTIVITY: 3\n};\n\nvar TXNDESCRIPTOR_HEADER_DATA_LEN = 4 + 8;\n\nvar TXNDESCRIPTOR_HEADER_LEN = 4 + 2 + TXNDESCRIPTOR_HEADER_DATA_LEN;\n\nmodule.exports.writeToTrackingBuffer = writeToTrackingBuffer;\nfunction writeToTrackingBuffer(buffer, txnDescriptor, outstandingRequestCount) {\n  buffer.writeUInt32LE(0);\n  buffer.writeUInt32LE(TXNDESCRIPTOR_HEADER_LEN);\n  buffer.writeUInt16LE(TYPE.TXN_DESCRIPTOR);\n  buffer.writeBuffer(txnDescriptor);\n  buffer.writeUInt32LE(outstandingRequestCount);\n\n  var data = buffer.data;\n  data.writeUInt32LE(data.length, 0);\n  return buffer;\n}","/home/travis/build/npmtest/node-npmtest-tedious/tedious/lib/sqlbatch-payload.js":"'use strict';\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar WritableTrackingBuffer = require('./tracking-buffer/tracking-buffer').WritableTrackingBuffer;\nvar writeAllHeaders = require('./all-headers').writeToTrackingBuffer;\n\n/*\n  s2.2.6.6\n */\nmodule.exports = function () {\n  function SqlBatchPayload(sqlText, txnDescriptor, options) {\n    (0, _classCallCheck3.default)(this, SqlBatchPayload);\n\n    this.sqlText = sqlText;\n\n    var buffer = new WritableTrackingBuffer(100 + 2 * this.sqlText.length, 'ucs2');\n    if (options.tdsVersion >= '7_2') {\n      var outstandingRequestCount = 1;\n      writeAllHeaders(buffer, txnDescriptor, outstandingRequestCount);\n    }\n    buffer.writeString(this.sqlText, 'ucs2');\n    this.data = buffer.data;\n  }\n\n  (0, _createClass3.default)(SqlBatchPayload, [{\n    key: 'toString',\n    value: function toString(indent) {\n      indent || (indent = '');\n      return indent + ('SQL Batch - ' + this.sqlText);\n    }\n  }]);\n  return SqlBatchPayload;\n}();","/home/travis/build/npmtest/node-npmtest-tedious/tedious/lib/message-io.js":"'use strict';\n\nvar _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = require('babel-runtime/helpers/inherits');\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar tls = require('tls');\nvar crypto = require('crypto');\nvar EventEmitter = require('events').EventEmitter;\nvar Transform = require('readable-stream').Transform;\n\nvar Packet = require('./packet').Packet;\nvar TYPE = require('./packet').TYPE;\nvar packetHeaderLength = require('./packet').HEADER_LENGTH;\n\nvar ReadablePacketStream = function (_Transform) {\n  (0, _inherits3.default)(ReadablePacketStream, _Transform);\n\n  function ReadablePacketStream() {\n    (0, _classCallCheck3.default)(this, ReadablePacketStream);\n\n    var _this = (0, _possibleConstructorReturn3.default)(this, (ReadablePacketStream.__proto__ || (0, _getPrototypeOf2.default)(ReadablePacketStream)).call(this, { objectMode: true }));\n\n    _this.buffer = new Buffer(0);\n    _this.position = 0;\n    return _this;\n  }\n\n  (0, _createClass3.default)(ReadablePacketStream, [{\n    key: '_transform',\n    value: function _transform(chunk, encoding, callback) {\n      if (this.position === this.buffer.length) {\n        // If we have fully consumed the previous buffer,\n        // we can just replace it with the new chunk\n        this.buffer = chunk;\n      } else {\n        // If we haven't fully consumed the previous buffer,\n        // we simply concatenate the leftovers and the new chunk.\n        this.buffer = Buffer.concat([this.buffer.slice(this.position), chunk], this.buffer.length - this.position + chunk.length);\n      }\n\n      this.position = 0;\n\n      // The packet header is always 8 bytes of length.\n      while (this.buffer.length >= this.position + packetHeaderLength) {\n        // Get the full packet length\n        var length = this.buffer.readUInt16BE(this.position + 2);\n\n        if (this.buffer.length >= this.position + length) {\n          var data = this.buffer.slice(this.position, this.position + length);\n          this.position += length;\n          this.push(new Packet(data));\n        } else {\n          // Not enough data to provide the next packet. Stop here and wait for\n          // the next call to `_transform`.\n          break;\n        }\n      }\n\n      callback();\n    }\n  }]);\n  return ReadablePacketStream;\n}(Transform);\n\nmodule.exports = function (_EventEmitter) {\n  (0, _inherits3.default)(MessageIO, _EventEmitter);\n\n  function MessageIO(socket, _packetSize, debug) {\n    (0, _classCallCheck3.default)(this, MessageIO);\n\n    var _this2 = (0, _possibleConstructorReturn3.default)(this, (MessageIO.__proto__ || (0, _getPrototypeOf2.default)(MessageIO)).call(this));\n\n    _this2.socket = socket;\n    _this2._packetSize = _packetSize;\n    _this2.debug = debug;\n    _this2.sendPacket = _this2.sendPacket.bind(_this2);\n\n    _this2.packetStream = new ReadablePacketStream();\n    _this2.packetStream.on('data', function (packet) {\n      _this2.logPacket('Received', packet);\n      _this2.emit('data', packet.data());\n      if (packet.isLast()) {\n        _this2.emit('message');\n      }\n    });\n\n    _this2.socket.pipe(_this2.packetStream);\n    _this2.packetDataSize = _this2._packetSize - packetHeaderLength;\n    return _this2;\n  }\n\n  (0, _createClass3.default)(MessageIO, [{\n    key: 'packetSize',\n    value: function packetSize(_packetSize2) {\n      if (arguments.length > 0) {\n        this.debug.log('Packet size changed from ' + this._packetSize + ' to ' + _packetSize2);\n        this._packetSize = _packetSize2;\n        this.packetDataSize = this._packetSize - packetHeaderLength;\n      }\n      return this._packetSize;\n    }\n  }, {\n    key: 'startTls',\n    value: function startTls(credentialsDetails, hostname, trustServerCertificate) {\n      var _this3 = this;\n\n      var credentials = tls.createSecureContext ? tls.createSecureContext(credentialsDetails) : crypto.createCredentials(credentialsDetails);\n\n      this.securePair = tls.createSecurePair(credentials);\n      this.tlsNegotiationComplete = false;\n\n      this.securePair.on('secure', function () {\n        var cipher = _this3.securePair.cleartext.getCipher();\n\n        if (!trustServerCertificate) {\n          var verifyError = _this3.securePair.ssl.verifyError();\n\n          // Verify that server's identity matches it's certificate's names\n          if (!verifyError) {\n            verifyError = tls.checkServerIdentity(hostname, _this3.securePair.cleartext.getPeerCertificate());\n          }\n\n          if (verifyError) {\n            _this3.securePair.destroy();\n            _this3.socket.destroy(verifyError);\n            return;\n          }\n        }\n\n        _this3.debug.log('TLS negotiated (' + cipher.name + ', ' + cipher.version + ')');\n        _this3.emit('secure', _this3.securePair.cleartext);\n        _this3.encryptAllFutureTraffic();\n      });\n\n      this.securePair.encrypted.on('data', function (data) {\n        _this3.sendMessage(TYPE.PRELOGIN, data);\n      });\n\n      // On Node >= 0.12, the encrypted stream automatically starts spewing out\n      // data once we attach a `data` listener. But on Node <= 0.10.x, this is not\n      // the case. We need to kick the cleartext stream once to get the\n      // encrypted end of the secure pair to emit the TLS handshake data.\n      this.securePair.cleartext.write('');\n    }\n  }, {\n    key: 'encryptAllFutureTraffic',\n    value: function encryptAllFutureTraffic() {\n      this.socket.unpipe(this.packetStream);\n      this.securePair.encrypted.removeAllListeners('data');\n      this.socket.pipe(this.securePair.encrypted);\n      this.securePair.encrypted.pipe(this.socket);\n      this.securePair.cleartext.pipe(this.packetStream);\n      this.tlsNegotiationComplete = true;\n    }\n  }, {\n    key: 'tlsHandshakeData',\n    value: function tlsHandshakeData(data) {\n      this.securePair.encrypted.write(data);\n    }\n\n    // TODO listen for 'drain' event when socket.write returns false.\n    // TODO implement incomplete request cancelation (2.2.1.6)\n\n  }, {\n    key: 'sendMessage',\n    value: function sendMessage(packetType, data, resetConnection) {\n      var numberOfPackets = void 0;\n      if (data) {\n        numberOfPackets = Math.floor((data.length - 1) / this.packetDataSize) + 1;\n      } else {\n        numberOfPackets = 1;\n        data = new Buffer(0);\n      }\n\n      for (var packetNumber = 0; packetNumber < numberOfPackets; packetNumber++) {\n        var payloadStart = packetNumber * this.packetDataSize;\n\n        var payloadEnd = void 0;\n        if (packetNumber < numberOfPackets - 1) {\n          payloadEnd = payloadStart + this.packetDataSize;\n        } else {\n          payloadEnd = data.length;\n        }\n\n        var packetPayload = data.slice(payloadStart, payloadEnd);\n\n        var packet = new Packet(packetType);\n        packet.last(packetNumber === numberOfPackets - 1);\n        packet.resetConnection(resetConnection);\n        packet.packetId(packetNumber + 1);\n        packet.addData(packetPayload);\n        this.sendPacket(packet);\n      }\n    }\n  }, {\n    key: 'sendPacket',\n    value: function sendPacket(packet) {\n      this.logPacket('Sent', packet);\n      if (this.securePair && this.tlsNegotiationComplete) {\n        this.securePair.cleartext.write(packet.buffer);\n      } else {\n        this.socket.write(packet.buffer);\n      }\n    }\n  }, {\n    key: 'logPacket',\n    value: function logPacket(direction, packet) {\n      this.debug.packet(direction, packet);\n      return this.debug.data(packet);\n    }\n  }]);\n  return MessageIO;\n}(EventEmitter);","/home/travis/build/npmtest/node-npmtest-tedious/tedious/lib/token/token-stream-parser.js":"'use strict';\n\nvar _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = require('babel-runtime/helpers/inherits');\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar EventEmitter = require('events').EventEmitter;\nvar StreamParser = require('./stream-parser');\n\n/*\n  Buffers are thrown at the parser (by calling addBuffer).\n  Tokens are parsed from the buffer until there are no more tokens in\n  the buffer, or there is just a partial token left.\n  If there is a partial token left over, then it is kept until another\n  buffer is added, which should contain the remainder of the partial\n  token, along with (perhaps) more tokens.\n  The partial token and the new buffer are concatenated, and the token\n  parsing resumes.\n */\n\nvar Parser = function (_EventEmitter) {\n  (0, _inherits3.default)(Parser, _EventEmitter);\n\n  function Parser(debug, colMetadata, options) {\n    (0, _classCallCheck3.default)(this, Parser);\n\n    var _this = (0, _possibleConstructorReturn3.default)(this, (Parser.__proto__ || (0, _getPrototypeOf2.default)(Parser)).call(this));\n\n    _this.debug = debug;\n    _this.colMetadata = _this.colMetadata;\n    _this.options = options;\n\n    _this.parser = new StreamParser(_this.debug, _this.colMetadata, _this.options);\n    _this.parser.on('data', function (token) {\n      if (token.event) {\n        _this.emit(token.event, token);\n      }\n    });\n    return _this;\n  }\n\n  (0, _createClass3.default)(Parser, [{\n    key: 'addBuffer',\n    value: function addBuffer(buffer) {\n      return this.parser.write(buffer);\n    }\n  }, {\n    key: 'isEnd',\n    value: function isEnd() {\n      return this.parser.buffer.length === this.parser.position;\n    }\n  }]);\n  return Parser;\n}(EventEmitter);\n\nmodule.exports.Parser = Parser;","/home/travis/build/npmtest/node-npmtest-tedious/tedious/lib/token/stream-parser.js":"'use strict';\n\nvar _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = require('babel-runtime/helpers/inherits');\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar Transform = require('readable-stream').Transform;\nvar TYPE = require('./token').TYPE;\n\nvar tokenParsers = {};\ntokenParsers[TYPE.COLMETADATA] = require('./colmetadata-token-parser');\ntokenParsers[TYPE.DONE] = require('./done-token-parser').doneParser;\ntokenParsers[TYPE.DONEINPROC] = require('./done-token-parser').doneInProcParser;\ntokenParsers[TYPE.DONEPROC] = require('./done-token-parser').doneProcParser;\ntokenParsers[TYPE.ENVCHANGE] = require('./env-change-token-parser');\ntokenParsers[TYPE.ERROR] = require('./infoerror-token-parser').errorParser;\ntokenParsers[TYPE.INFO] = require('./infoerror-token-parser').infoParser;\ntokenParsers[TYPE.LOGINACK] = require('./loginack-token-parser');\ntokenParsers[TYPE.ORDER] = require('./order-token-parser');\ntokenParsers[TYPE.RETURNSTATUS] = require('./returnstatus-token-parser');\ntokenParsers[TYPE.RETURNVALUE] = require('./returnvalue-token-parser');\ntokenParsers[TYPE.ROW] = require('./row-token-parser');\ntokenParsers[TYPE.NBCROW] = require('./nbcrow-token-parser');\ntokenParsers[TYPE.SSPI] = require('./sspi-token-parser');\n\nmodule.exports = function (_Transform) {\n  (0, _inherits3.default)(Parser, _Transform);\n\n  function Parser(debug, colMetadata, options) {\n    (0, _classCallCheck3.default)(this, Parser);\n\n    var _this = (0, _possibleConstructorReturn3.default)(this, (Parser.__proto__ || (0, _getPrototypeOf2.default)(Parser)).call(this, { objectMode: true }));\n\n    _this.debug = debug;\n    _this.colMetadata = colMetadata;\n    _this.options = options;\n\n    _this.buffer = new Buffer(0);\n    _this.position = 0;\n    _this.suspended = false;\n    _this.await = undefined;\n    _this.next = undefined;\n    return _this;\n  }\n\n  (0, _createClass3.default)(Parser, [{\n    key: '_transform',\n    value: function _transform(input, encoding, done) {\n      if (this.position === this.buffer.length) {\n        this.buffer = input;\n      } else {\n        this.buffer = Buffer.concat([this.buffer.slice(this.position), input]);\n      }\n      this.position = 0;\n\n      // This will be called once we need to wait for more data to\n      // become available\n      this.await = done;\n\n      if (this.suspended) {\n        // Unsuspend and continue from where ever we left off.\n        this.suspended = false;\n        this.next.call(null);\n      }\n\n      // If we're no longer suspended, parse new tokens\n      if (!this.suspended) {\n        // Start the parser\n        this.parseTokens();\n      }\n    }\n  }, {\n    key: 'parseTokens',\n    value: function parseTokens() {\n      var _this2 = this;\n\n      var doneParsing = function doneParsing(token) {\n        if (token) {\n          switch (token.name) {\n            case 'COLMETADATA':\n              _this2.colMetadata = token.columns;\n          }\n\n          _this2.push(token);\n        }\n      };\n\n      while (!this.suspended && this.position + 1 <= this.buffer.length) {\n        var type = this.buffer.readUInt8(this.position, true);\n\n        this.position += 1;\n\n        if (tokenParsers[type]) {\n          tokenParsers[type](this, this.colMetadata, this.options, doneParsing);\n        } else {\n          this.emit('error', new Error('Unknown type: ' + type));\n        }\n      }\n\n      if (!this.suspended && this.position === this.buffer.length) {\n        // If we reached the end of the buffer, we can stop parsing now.\n        return this.await.call(null);\n      }\n    }\n  }, {\n    key: 'suspend',\n    value: function suspend(next) {\n      this.suspended = true;\n      this.next = next;\n      this.await.call(null);\n    }\n  }, {\n    key: 'awaitData',\n    value: function awaitData(length, callback) {\n      var _this3 = this;\n\n      if (this.position + length <= this.buffer.length) {\n        callback();\n      } else {\n        this.suspend(function () {\n          _this3.awaitData(length, callback);\n        });\n      }\n    }\n  }, {\n    key: 'readInt8',\n    value: function readInt8(callback) {\n      var _this4 = this;\n\n      this.awaitData(1, function () {\n        var data = _this4.buffer.readInt8(_this4.position);\n        _this4.position += 1;\n        callback(data);\n      });\n    }\n  }, {\n    key: 'readUInt8',\n    value: function readUInt8(callback) {\n      var _this5 = this;\n\n      this.awaitData(1, function () {\n        var data = _this5.buffer.readUInt8(_this5.position);\n        _this5.position += 1;\n        callback(data);\n      });\n    }\n  }, {\n    key: 'readInt16LE',\n    value: function readInt16LE(callback) {\n      var _this6 = this;\n\n      this.awaitData(2, function () {\n        var data = _this6.buffer.readInt16LE(_this6.position);\n        _this6.position += 2;\n        callback(data);\n      });\n    }\n  }, {\n    key: 'readInt16BE',\n    value: function readInt16BE(callback) {\n      var _this7 = this;\n\n      this.awaitData(2, function () {\n        var data = _this7.buffer.readInt16BE(_this7.position);\n        _this7.position += 2;\n        callback(data);\n      });\n    }\n  }, {\n    key: 'readUInt16LE',\n    value: function readUInt16LE(callback) {\n      var _this8 = this;\n\n      this.awaitData(2, function () {\n        var data = _this8.buffer.readUInt16LE(_this8.position);\n        _this8.position += 2;\n        callback(data);\n      });\n    }\n  }, {\n    key: 'readUInt16BE',\n    value: function readUInt16BE(callback) {\n      var _this9 = this;\n\n      this.awaitData(2, function () {\n        var data = _this9.buffer.readUInt16BE(_this9.position);\n        _this9.position += 2;\n        callback(data);\n      });\n    }\n  }, {\n    key: 'readInt32LE',\n    value: function readInt32LE(callback) {\n      var _this10 = this;\n\n      this.awaitData(4, function () {\n        var data = _this10.buffer.readInt32LE(_this10.position);\n        _this10.position += 4;\n        callback(data);\n      });\n    }\n  }, {\n    key: 'readInt32BE',\n    value: function readInt32BE(callback) {\n      var _this11 = this;\n\n      this.awaitData(4, function () {\n        var data = _this11.buffer.readInt32BE(_this11.position);\n        _this11.position += 4;\n        callback(data);\n      });\n    }\n  }, {\n    key: 'readUInt32LE',\n    value: function readUInt32LE(callback) {\n      var _this12 = this;\n\n      this.awaitData(4, function () {\n        var data = _this12.buffer.readUInt32LE(_this12.position);\n        _this12.position += 4;\n        callback(data);\n      });\n    }\n  }, {\n    key: 'readUInt32BE',\n    value: function readUInt32BE(callback) {\n      var _this13 = this;\n\n      this.awaitData(4, function () {\n        var data = _this13.buffer.readUInt32BE(_this13.position);\n        _this13.position += 4;\n        callback(data);\n      });\n    }\n  }, {\n    key: 'readInt64LE',\n    value: function readInt64LE(callback) {\n      var _this14 = this;\n\n      this.awaitData(8, function () {\n        var data = Math.pow(2, 32) * _this14.buffer.readInt32LE(_this14.position + 4) + (_this14.buffer[_this14.position + 4] & 0x80 === 0x80 ? 1 : -1) * _this14.buffer.readUInt32LE(_this14.position);\n        _this14.position += 8;\n        callback(data);\n      });\n    }\n  }, {\n    key: 'readInt64BE',\n    value: function readInt64BE(callback) {\n      var _this15 = this;\n\n      this.awaitData(8, function () {\n        var data = Math.pow(2, 32) * _this15.buffer.readInt32BE(_this15.position) + (_this15.buffer[_this15.position] & 0x80 === 0x80 ? 1 : -1) * _this15.buffer.readUInt32BE(_this15.position + 4);\n        _this15.position += 8;\n        callback(data);\n      });\n    }\n  }, {\n    key: 'readUInt64LE',\n    value: function readUInt64LE(callback) {\n      var _this16 = this;\n\n      this.awaitData(8, function () {\n        var data = Math.pow(2, 32) * _this16.buffer.readUInt32LE(_this16.position + 4) + _this16.buffer.readUInt32LE(_this16.position);\n        _this16.position += 8;\n        callback(data);\n      });\n    }\n  }, {\n    key: 'readUInt64BE',\n    value: function readUInt64BE(callback) {\n      var _this17 = this;\n\n      this.awaitData(8, function () {\n        var data = Math.pow(2, 32) * _this17.buffer.readUInt32BE(_this17.position) + _this17.buffer.readUInt32BE(_this17.position + 4);\n        _this17.position += 8;\n        callback(data);\n      });\n    }\n  }, {\n    key: 'readFloatLE',\n    value: function readFloatLE(callback) {\n      var _this18 = this;\n\n      this.awaitData(4, function () {\n        var data = _this18.buffer.readFloatLE(_this18.position);\n        _this18.position += 4;\n        callback(data);\n      });\n    }\n  }, {\n    key: 'readFloatBE',\n    value: function readFloatBE(callback) {\n      var _this19 = this;\n\n      this.awaitData(4, function () {\n        var data = _this19.buffer.readFloatBE(_this19.position);\n        _this19.position += 4;\n        callback(data);\n      });\n    }\n  }, {\n    key: 'readDoubleLE',\n    value: function readDoubleLE(callback) {\n      var _this20 = this;\n\n      this.awaitData(8, function () {\n        var data = _this20.buffer.readDoubleLE(_this20.position);\n        _this20.position += 8;\n        callback(data);\n      });\n    }\n  }, {\n    key: 'readDoubleBE',\n    value: function readDoubleBE(callback) {\n      var _this21 = this;\n\n      this.awaitData(8, function () {\n        var data = _this21.buffer.readDoubleBE(_this21.position);\n        _this21.position += 8;\n        callback(data);\n      });\n    }\n  }, {\n    key: 'readUInt24LE',\n    value: function readUInt24LE(callback) {\n      var _this22 = this;\n\n      this.awaitData(3, function () {\n        var low = _this22.buffer.readUInt16LE(_this22.position);\n        var high = _this22.buffer.readUInt8(_this22.position + 2);\n\n        _this22.position += 3;\n\n        callback(low | high << 16);\n      });\n    }\n  }, {\n    key: 'readUInt40LE',\n    value: function readUInt40LE(callback) {\n      var _this23 = this;\n\n      this.awaitData(5, function () {\n        var low = _this23.buffer.readUInt32LE(_this23.position);\n        var high = _this23.buffer.readUInt8(_this23.position + 4);\n\n        _this23.position += 5;\n\n        callback(0x100000000 * high + low);\n      });\n    }\n  }, {\n    key: 'readUNumeric64LE',\n    value: function readUNumeric64LE(callback) {\n      var _this24 = this;\n\n      this.awaitData(8, function () {\n        var low = _this24.buffer.readUInt32LE(_this24.position);\n        var high = _this24.buffer.readUInt32LE(_this24.position + 4);\n\n        _this24.position += 8;\n\n        callback(0x100000000 * high + low);\n      });\n    }\n  }, {\n    key: 'readUNumeric96LE',\n    value: function readUNumeric96LE(callback) {\n      var _this25 = this;\n\n      this.awaitData(12, function () {\n        var dword1 = _this25.buffer.readUInt32LE(_this25.position);\n        var dword2 = _this25.buffer.readUInt32LE(_this25.position + 4);\n        var dword3 = _this25.buffer.readUInt32LE(_this25.position + 8);\n\n        _this25.position += 12;\n\n        callback(dword1 + 0x100000000 * dword2 + 0x100000000 * 0x100000000 * dword3);\n      });\n    }\n  }, {\n    key: 'readUNumeric128LE',\n    value: function readUNumeric128LE(callback) {\n      var _this26 = this;\n\n      this.awaitData(16, function () {\n        var dword1 = _this26.buffer.readUInt32LE(_this26.position);\n        var dword2 = _this26.buffer.readUInt32LE(_this26.position + 4);\n        var dword3 = _this26.buffer.readUInt32LE(_this26.position + 8);\n        var dword4 = _this26.buffer.readUInt32LE(_this26.position + 12);\n\n        _this26.position += 16;\n\n        callback(dword1 + 0x100000000 * dword2 + 0x100000000 * 0x100000000 * dword3 + 0x100000000 * 0x100000000 * 0x100000000 * dword4);\n      });\n    }\n\n    // Variable length data\n\n  }, {\n    key: 'readBuffer',\n    value: function readBuffer(length, callback) {\n      var _this27 = this;\n\n      this.awaitData(length, function () {\n        var data = _this27.buffer.slice(_this27.position, _this27.position + length);\n        _this27.position += length;\n        callback(data);\n      });\n    }\n\n    // Read a Unicode String (BVARCHAR)\n\n  }, {\n    key: 'readBVarChar',\n    value: function readBVarChar(callback) {\n      var _this28 = this;\n\n      this.readUInt8(function (length) {\n        _this28.readBuffer(length * 2, function (data) {\n          callback(data.toString('ucs2'));\n        });\n      });\n    }\n\n    // Read a Unicode String (USVARCHAR)\n\n  }, {\n    key: 'readUsVarChar',\n    value: function readUsVarChar(callback) {\n      var _this29 = this;\n\n      this.readUInt16LE(function (length) {\n        _this29.readBuffer(length * 2, function (data) {\n          callback(data.toString('ucs2'));\n        });\n      });\n    }\n\n    // Read binary data (BVARBYTE)\n\n  }, {\n    key: 'readBVarByte',\n    value: function readBVarByte(callback) {\n      var _this30 = this;\n\n      this.readUInt8(function (length) {\n        _this30.readBuffer(length, callback);\n      });\n    }\n\n    // Read binary data (USVARBYTE)\n\n  }, {\n    key: 'readUsVarByte',\n    value: function readUsVarByte(callback) {\n      var _this31 = this;\n\n      this.readUInt16LE(function (length) {\n        _this31.readBuffer(length, callback);\n      });\n    }\n  }]);\n  return Parser;\n}(Transform);","/home/travis/build/npmtest/node-npmtest-tedious/tedious/lib/token/colmetadata-token-parser.js":"'use strict';\n\nvar metadataParse = require('../metadata-parser');\n\nfunction readTableName(parser, options, metadata, callback) {\n  if (metadata.type.hasTableName) {\n    if (options.tdsVersion >= '7_2') {\n      parser.readUInt8(function (numberOfTableNameParts) {\n        var tableName = [];\n\n        var i = 0;\n        function next(done) {\n          if (numberOfTableNameParts === i) {\n            return done();\n          }\n\n          parser.readUsVarChar(function (part) {\n            tableName.push(part);\n\n            i++;\n\n            next(done);\n          });\n        }\n\n        next(function () {\n          callback(tableName);\n        });\n      });\n    } else {\n      parser.readUsVarChar(callback);\n    }\n  } else {\n    callback(undefined);\n  }\n}\n\nfunction readColumnName(parser, options, index, metadata, callback) {\n  parser.readBVarChar(function (colName) {\n    if (options.columnNameReplacer) {\n      callback(options.columnNameReplacer(colName, index, metadata));\n    } else if (options.camelCaseColumns) {\n      callback(colName.replace(/^[A-Z]/, function (s) {\n        return s.toLowerCase();\n      }));\n    } else {\n      callback(colName);\n    }\n  });\n}\n\nfunction readColumn(parser, options, index, callback) {\n  metadataParse(parser, options, function (metadata) {\n    readTableName(parser, options, metadata, function (tableName) {\n      readColumnName(parser, options, index, metadata, function (colName) {\n        callback({\n          userType: metadata.userType,\n          flags: metadata.flags,\n          type: metadata.type,\n          colName: colName,\n          collation: metadata.collation,\n          precision: metadata.precision,\n          scale: metadata.scale,\n          udtInfo: metadata.udtInfo,\n          dataLength: metadata.dataLength,\n          tableName: tableName\n        });\n      });\n    });\n  });\n}\n\nmodule.exports = function (parser, colMetadata, options, callback) {\n  parser.readUInt16LE(function (columnCount) {\n    var columns = [];\n\n    var i = 0;\n    function next(done) {\n      if (i === columnCount) {\n        return done();\n      }\n\n      readColumn(parser, options, i, function (column) {\n        columns.push(column);\n\n        i++;\n        next(done);\n      });\n    }\n\n    next(function () {\n      callback({\n        name: 'COLMETADATA',\n        event: 'columnMetadata',\n        columns: columns\n      });\n    });\n  });\n};","/home/travis/build/npmtest/node-npmtest-tedious/tedious/lib/metadata-parser.js":"'use strict';\n\nvar codepageBySortId = require('./collation').codepageBySortId;\nvar codepageByLcid = require('./collation').codepageByLcid;\nvar TYPE = require('./data-type').TYPE;\nvar sprintf = require('sprintf').sprintf;\n\nmodule.exports = metadataParse;\nmodule.exports.readPrecision = readPrecision;\nmodule.exports.readScale = readScale;\nmodule.exports.readCollation = readCollation;\n\nfunction readDataLength(parser, type, callback) {\n  if ((type.id & 0x30) === 0x20) {\n    // xx10xxxx - s2.2.4.2.1.3\n    // Variable length\n    if (type.dataLengthFromScale) {\n      return callback(0); // dataLength is resolved from scale\n    } else if (type.fixedDataLength) {\n      return callback(type.fixedDataLength);\n    }\n\n    switch (type.dataLengthLength) {\n      case 0:\n        return callback(undefined);\n\n      case 1:\n        return parser.readUInt8(callback);\n\n      case 2:\n        return parser.readUInt16LE(callback);\n\n      case 4:\n        return parser.readUInt32LE(callback);\n\n      default:\n        return parser.emit(new Error('Unsupported dataLengthLength ' + type.dataLengthLength + ' for data type ' + type.name));\n    }\n  } else {\n    callback(undefined);\n  }\n}\n\nfunction readPrecision(parser, type, callback) {\n  if (type.hasPrecision) {\n    parser.readUInt8(callback);\n  } else {\n    callback(undefined);\n  }\n}\n\nfunction readScale(parser, type, callback) {\n  if (type.hasScale) {\n    parser.readUInt8(callback);\n  } else {\n    callback(undefined);\n  }\n}\n\nfunction readCollation(parser, type, callback) {\n  if (type.hasCollation) {\n    // s2.2.5.1.2\n    parser.readBuffer(5, function (collationData) {\n      var collation = {};\n\n      collation.lcid = (collationData[2] & 0x0F) << 16;\n      collation.lcid |= collationData[1] << 8;\n      collation.lcid |= collationData[0];\n\n      // This may not be extracting the correct nibbles in the correct order.\n      collation.flags = collationData[3] >> 4;\n      collation.flags |= collationData[2] & 0xF0;\n\n      // This may not be extracting the correct nibble.\n      collation.version = collationData[3] & 0x0F;\n\n      collation.sortId = collationData[4];\n\n      collation.codepage = codepageBySortId[collation.sortId] || codepageByLcid[collation.lcid] || 'CP1252';\n\n      callback(collation);\n    });\n  } else {\n    callback(undefined);\n  }\n}\n\nfunction readSchema(parser, type, callback) {\n  if (type.hasSchemaPresent) {\n    // s2.2.5.5.3\n    parser.readUInt8(function (schemaPresent) {\n      if (schemaPresent === 0x01) {\n        parser.readBVarChar(function (dbname) {\n          parser.readBVarChar(function (owningSchema) {\n            parser.readUsVarChar(function (xmlSchemaCollection) {\n              callback({\n                dbname: dbname,\n                owningSchema: owningSchema,\n                xmlSchemaCollection: xmlSchemaCollection\n              });\n            });\n          });\n        });\n      } else {\n        callback(undefined);\n      }\n    });\n  } else {\n    callback(undefined);\n  }\n}\n\nfunction readUDTInfo(parser, type, callback) {\n  if (type.hasUDTInfo) {\n    parser.readUInt16LE(function (maxByteSize) {\n      parser.readBVarChar(function (dbname) {\n        parser.readBVarChar(function (owningSchema) {\n          parser.readBVarChar(function (typeName) {\n            parser.readUsVarChar(function (assemblyName) {\n              callback({\n                maxByteSize: maxByteSize,\n                dbname: dbname,\n                owningSchema: owningSchema,\n                typeName: typeName,\n                assemblyName: assemblyName\n              });\n            });\n          });\n        });\n      });\n    });\n  } else {\n    return callback();\n  }\n}\n\nfunction metadataParse(parser, options, callback) {\n  (options.tdsVersion < '7_2' ? parser.readUInt16LE : parser.readUInt32LE).call(parser, function (userType) {\n    parser.readUInt16LE(function (flags) {\n      parser.readUInt8(function (typeNumber) {\n        var type = TYPE[typeNumber];\n\n        if (!type) {\n          return parser.emit(new Error(sprintf('Unrecognised data type 0x%02X', typeNumber)));\n        }\n\n        readDataLength(parser, type, function (dataLength) {\n          readPrecision(parser, type, function (precision) {\n            readScale(parser, type, function (scale) {\n              if (scale && type.dataLengthFromScale) {\n                dataLength = type.dataLengthFromScale(scale);\n              }\n\n              readCollation(parser, type, function (collation) {\n                readSchema(parser, type, function (schema) {\n                  readUDTInfo(parser, type, function (udtInfo) {\n                    callback({\n                      userType: userType,\n                      flags: flags,\n                      type: type,\n                      collation: collation,\n                      precision: precision,\n                      scale: scale,\n                      dataLength: dataLength,\n                      schema: schema,\n                      udtInfo: udtInfo\n                    });\n                  });\n                });\n              });\n            });\n          });\n        });\n      });\n    });\n  });\n}","/home/travis/build/npmtest/node-npmtest-tedious/tedious/lib/collation.js":"'use strict';\n\n// http://technet.microsoft.com/en-us/library/aa176553(v=sql.80).aspx\n\nmodule.exports.codepageByLcid = {\n  0x436: 'CP1252',\n  0x401: 'CP1256',\n  0x801: 'CP1256',\n  0xC01: 'CP1256',\n  0x1001: 'CP1256',\n  0x1401: 'CP1256',\n  0x1801: 'CP1256',\n  0x1C01: 'CP1256',\n  0x2001: 'CP1256',\n  0x2401: 'CP1256',\n  0x2801: 'CP1256',\n  0x2C01: 'CP1256',\n  0x3001: 'CP1256',\n  0x3401: 'CP1256',\n  0x3801: 'CP1256',\n  0x3C01: 'CP1256',\n  0x4001: 'CP1256',\n  0x42D: 'CP1252',\n  0x423: 'CP1251',\n  0x402: 'CP1251',\n  0x403: 'CP1252',\n  0x30404: 'CP950',\n  0x404: 'CP950',\n  0x804: 'CP936',\n  0x20804: 'CP936',\n  0x1004: 'CP936',\n  0x41a: 'CP1250',\n  0x405: 'CP1250',\n  0x406: 'CP1252',\n  0x413: 'CP1252',\n  0x813: 'CP1252',\n  0x409: 'CP1252',\n  0x809: 'CP1252',\n  0x1009: 'CP1252',\n  0x1409: 'CP1252',\n  0xC09: 'CP1252',\n  0x1809: 'CP1252',\n  0x1C09: 'CP1252',\n  0x2409: 'CP1252',\n  0x2009: 'CP1252',\n  0x425: 'CP1257',\n  0x0438: 'CP1252',\n  0x429: 'CP1256',\n  0x40B: 'CP1252',\n  0x40C: 'CP1252',\n  0x80C: 'CP1252',\n  0x100C: 'CP1252',\n  0xC0C: 'CP1252',\n  0x140C: 'CP1252',\n  0x10437: 'CP1252',\n  0x10407: 'CP1252',\n  0x407: 'CP1252',\n  0x807: 'CP1252',\n  0xC07: 'CP1252',\n  0x1007: 'CP1252',\n  0x1407: 'CP1252',\n  0x408: 'CP1253',\n  0x40D: 'CP1255',\n  0x439: 'CPUTF8',\n  0x40E: 'CP1250',\n  0x104E: 'CP1250',\n  0x40F: 'CP1252',\n  0x421: 'CP1252',\n  0x410: 'CP1252',\n  0x810: 'CP1252',\n  0x411: 'CP932',\n  0x10411: 'CP932',\n  0x412: 'CP949',\n  0x426: 'CP1257',\n  0x427: 'CP1257',\n  0x827: 'CP1257',\n  0x41C: 'CP1251',\n  0x414: 'CP1252',\n  0x814: 'CP1252',\n  0x415: 'CP1250',\n  0x816: 'CP1252',\n  0x416: 'CP1252',\n  0x418: 'CP1250',\n  0x419: 'CP1251',\n  0x81A: 'CP1251',\n  0xC1A: 'CP1251',\n  0x41B: 'CP1250',\n  0x424: 'CP1250',\n  0x80A: 'CP1252',\n  0x40A: 'CP1252',\n  0xC0A: 'CP1252',\n  0x100A: 'CP1252',\n  0x140A: 'CP1252',\n  0x180A: 'CP1252',\n  0x1C0A: 'CP1252',\n  0x200A: 'CP1252',\n  0x240A: 'CP1252',\n  0x280A: 'CP1252',\n  0x2C0A: 'CP1252',\n  0x300A: 'CP1252',\n  0x340A: 'CP1252',\n  0x380A: 'CP1252',\n  0x3C0A: 'CP1252',\n  0x400A: 'CP1252',\n  0x41D: 'CP1252',\n  0x41E: 'CP874',\n  0x41F: 'CP1254',\n  0x422: 'CP1251',\n  0x420: 'CP1256',\n  0x42A: 'CP1258'\n};\n\nmodule.exports.codepageBySortId = {\n  30: 'CP437', // SQL_Latin1_General_CP437_BIN\n  31: 'CP437', // SQL_Latin1_General_CP437_CS_AS\n  32: 'CP437', // SQL_Latin1_General_CP437_CI_AS\n  33: 'CP437', // SQL_Latin1_General_Pref_CP437_CI_AS\n  34: 'CP437', // SQL_Latin1_General_CP437_CI_AI\n  40: 'CP850', // SQL_Latin1_General_CP850_BIN\n  41: 'CP850', // SQL_Latin1_General_CP850_CS_AS\n  42: 'CP850', // SQL_Latin1_General_CP850_CI_AS\n  43: 'CP850', // SQL_Latin1_General_Pref_CP850_CI_AS\n  44: 'CP850', // SQL_Latin1_General_CP850_CI_AI\n  49: 'CP850', // SQL_1xCompat_CP850_CI_AS\n  51: 'CP1252', // SQL_Latin1_General_Cp1_CS_AS_KI_WI\n  52: 'CP1252', // SQL_Latin1_General_Cp1_CI_AS_KI_WI\n  53: 'CP1252', // SQL_Latin1_General_Pref_Cp1_CI_AS_KI_WI\n  54: 'CP1252', // SQL_Latin1_General_Cp1_CI_AI_KI_WI\n  55: 'CP850', // SQL_AltDiction_CP850_CS_AS\n  56: 'CP850', // SQL_AltDiction_Pref_CP850_CI_AS\n  57: 'CP850', // SQL_AltDiction_CP850_CI_AI\n  58: 'CP850', // SQL_Scandinavian_Pref_CP850_CI_AS\n  59: 'CP850', // SQL_Scandinavian_CP850_CS_AS\n  60: 'CP850', // SQL_Scandinavian_CP850_CI_AS\n  61: 'CP850', // SQL_AltDiction_CP850_CI_AS\n  80: 'CP1250', // SQL_Latin1_General_1250_BIN\n  81: 'CP1250', // SQL_Latin1_General_CP1250_CS_AS\n  82: 'CP1250', // SQL_Latin1_General_Cp1250_CI_AS_KI_WI\n  83: 'CP1250', // SQL_Czech_Cp1250_CS_AS_KI_WI\n  84: 'CP1250', // SQL_Czech_Cp1250_CI_AS_KI_WI\n  85: 'CP1250', // SQL_Hungarian_Cp1250_CS_AS_KI_WI\n  86: 'CP1250', // SQL_Hungarian_Cp1250_CI_AS_KI_WI\n  87: 'CP1250', // SQL_Polish_Cp1250_CS_AS_KI_WI\n  88: 'CP1250', // SQL_Polish_Cp1250_CI_AS_KI_WI\n  89: 'CP1250', // SQL_Romanian_Cp1250_CS_AS_KI_WI\n  90: 'CP1250', // SQL_Romanian_Cp1250_CI_AS_KI_WI\n  91: 'CP1250', // SQL_Croatian_Cp1250_CS_AS_KI_WI\n  92: 'CP1250', // SQL_Croatian_Cp1250_CI_AS_KI_WI\n  93: 'CP1250', // SQL_Slovak_Cp1250_CS_AS_KI_WI\n  94: 'CP1250', // SQL_Slovak_Cp1250_CI_AS_KI_WI\n  95: 'CP1250', // SQL_Slovenian_Cp1250_CS_AS_KI_WI\n  96: 'CP1250', // SQL_Slovenian_Cp1250_CI_AS_KI_WI\n  104: 'CP1251', // SQL_Latin1_General_1251_BIN\n  105: 'CP1251', // SQL_Latin1_General_CP1251_CS_AS\n  106: 'CP1251', // SQL_Latin1_General_CP1251_CI_AS\n  107: 'CP1251', // SQL_Ukrainian_Cp1251_CS_AS_KI_WI\n  108: 'CP1251', // SQL_Ukrainian_Cp1251_CI_AS_KI_WI\n  112: 'CP1253', // SQL_Latin1_General_1253_BIN\n  113: 'CP1253', // SQL_Latin1_General_CP1253_CS_AS\n  114: 'CP1253', // SQL_Latin1_General_CP1253_CI_AS\n  120: 'CP1253', // SQL_MixDiction_CP1253_CS_AS\n  121: 'CP1253', // SQL_AltDiction_CP1253_CS_AS\n  122: 'CP1253', // SQL_AltDiction2_CP1253_CS_AS\n  124: 'CP1253', // SQL_Latin1_General_CP1253_CI_AI\n  128: 'CP1254', // SQL_Latin1_General_1254_BIN\n  129: 'CP1254', // SQL_Latin1_General_Cp1254_CS_AS_KI_WI\n  130: 'CP1254', // SQL_Latin1_General_Cp1254_CI_AS_KI_WI\n  136: 'CP1255', // SQL_Latin1_General_1255_BIN\n  137: 'CP1255', // SQL_Latin1_General_CP1255_CS_AS\n  138: 'CP1255', // SQL_Latin1_General_CP1255_CI_AS\n  144: 'CP1256', // SQL_Latin1_General_1256_BIN\n  145: 'CP1256', // SQL_Latin1_General_CP1256_CS_AS\n  146: 'CP1256', // SQL_Latin1_General_CP1256_CI_AS\n  152: 'CP1257', // SQL_Latin1_General_1257_BIN\n  153: 'CP1257', // SQL_Latin1_General_CP1257_CS_AS\n  154: 'CP1257', // SQL_Latin1_General_CP1257_CI_AS\n  155: 'CP1257', // SQL_Estonian_Cp1257_CS_AS_KI_WI\n  156: 'CP1257', // SQL_Estonian_Cp1257_CI_AS_KI_WI\n  157: 'CP1257', // SQL_Latvian_Cp1257_CS_AS_KI_WI\n  158: 'CP1257', // SQL_Latvian_Cp1257_CI_AS_KI_WI\n  159: 'CP1257', // SQL_Lithuanian_Cp1257_CS_AS_KI_WI\n  160: 'CP1257', // SQL_Lithuanian_Cp1257_CI_AS_KI_WI\n  183: 'CP1252', // SQL_Danish_Pref_Cp1_CI_AS_KI_WI\n  184: 'CP1252', // SQL_SwedishPhone_Pref_Cp1_CI_AS_KI_WI\n  185: 'CP1252', // SQL_SwedishStd_Pref_Cp1_CI_AS_KI_WI\n  186: 'CP1252' // SQL_Icelandic_Pref_Cp1_CI_AS_KI_WI\n};","/home/travis/build/npmtest/node-npmtest-tedious/tedious/lib/token/done-token-parser.js":"'use strict';\n\n// s2.2.7.5/6/7\n\nvar STATUS = {\n  MORE: 0x0001,\n  ERROR: 0x0002,\n  // This bit is not yet in use by SQL Server, so is not exposed in the returned token\n  INXACT: 0x0004,\n  COUNT: 0x0010,\n  ATTN: 0x0020,\n  SRVERROR: 0x0100\n};\n\nfunction parseToken(parser, options, callback) {\n  parser.readUInt16LE(function (status) {\n    var more = !!(status & STATUS.MORE);\n    var sqlError = !!(status & STATUS.ERROR);\n    var rowCountValid = !!(status & STATUS.COUNT);\n    var attention = !!(status & STATUS.ATTN);\n    var serverError = !!(status & STATUS.SRVERROR);\n\n    parser.readUInt16LE(function (curCmd) {\n      (options.tdsVersion < '7_2' ? parser.readUInt32LE : parser.readUInt64LE).call(parser, function (rowCount) {\n        callback({\n          name: 'DONE',\n          event: 'done',\n          more: more,\n          sqlError: sqlError,\n          attention: attention,\n          serverError: serverError,\n          rowCount: rowCountValid ? rowCount : undefined,\n          curCmd: curCmd\n        });\n      });\n    });\n  });\n}\n\nmodule.exports.doneParser = doneParser;\nfunction doneParser(parser, colMetadata, options, callback) {\n  parseToken(parser, options, function (token) {\n    token.name = 'DONE';\n    token.event = 'done';\n    callback(token);\n  });\n}\n\nmodule.exports.doneInProcParser = doneInProcParser;\nfunction doneInProcParser(parser, colMetadata, options, callback) {\n  parseToken(parser, options, function (token) {\n    token.name = 'DONEINPROC';\n    token.event = 'doneInProc';\n    callback(token);\n  });\n}\n\nmodule.exports.doneProcParser = doneProcParser;\nfunction doneProcParser(parser, colMetadata, options, callback) {\n  parseToken(parser, options, function (token) {\n    token.name = 'DONEPROC';\n    token.event = 'doneProc';\n    callback(token);\n  });\n}","/home/travis/build/npmtest/node-npmtest-tedious/tedious/lib/token/env-change-token-parser.js":"'use strict';\n\nvar types = {\n  1: {\n    name: 'DATABASE',\n    event: 'databaseChange'\n  },\n  2: {\n    name: 'LANGUAGE',\n    event: 'languageChange'\n  },\n  3: {\n    name: 'CHARSET',\n    event: 'charsetChange'\n  },\n  4: {\n    name: 'PACKET_SIZE',\n    event: 'packetSizeChange'\n  },\n  7: {\n    name: 'SQL_COLLATION',\n    event: 'sqlCollationChange'\n  },\n  8: {\n    name: 'BEGIN_TXN',\n    event: 'beginTransaction'\n  },\n  9: {\n    name: 'COMMIT_TXN',\n    event: 'commitTransaction'\n  },\n  10: {\n    name: 'ROLLBACK_TXN',\n    event: 'rollbackTransaction'\n  },\n  13: {\n    name: 'DATABASE_MIRRORING_PARTNER',\n    event: 'partnerNode'\n  },\n  17: {\n    name: 'TXN_ENDED'\n  },\n  18: {\n    name: 'RESET_CONNECTION',\n    event: 'resetConnection'\n  },\n  20: {\n    name: 'ROUTING_CHANGE',\n    event: 'routingChange'\n  }\n};\n\nfunction readNewAndOldValue(parser, length, type, callback) {\n  switch (type.name) {\n    case 'DATABASE':\n    case 'LANGUAGE':\n    case 'CHARSET':\n    case 'PACKET_SIZE':\n    case 'DATABASE_MIRRORING_PARTNER':\n      return parser.readBVarChar(function (newValue) {\n        parser.readBVarChar(function (oldValue) {\n          if (type.name === 'PACKET_SIZE') {\n            callback(parseInt(newValue), parseInt(oldValue));\n          } else {\n            callback(newValue, oldValue);\n          }\n        });\n      });\n\n    case 'SQL_COLLATION':\n    case 'BEGIN_TXN':\n    case 'COMMIT_TXN':\n    case 'ROLLBACK_TXN':\n    case 'RESET_CONNECTION':\n      return parser.readBVarByte(function (newValue) {\n        parser.readBVarByte(function (oldValue) {\n          callback(newValue, oldValue);\n        });\n      });\n\n    case 'ROUTING_CHANGE':\n      parser.readUInt16LE(function (valueLength) {\n        // Routing Change:\n        // Byte 1: Protocol (must be 0)\n        // Bytes 2-3 (USHORT): Port number\n        // Bytes 4-5 (USHORT): Length of server data in unicode (2byte chars)\n        // Bytes 6-*: Server name in unicode characters\n        parser.readBuffer(valueLength, function (routePacket) {\n          var protocol = routePacket.readUInt8(0);\n\n          if (protocol !== 0) {\n            return parser.emit('error', new Error('Unknown protocol byte in routing change event'));\n          }\n\n          var port = routePacket.readUInt16LE(1);\n          var serverLen = routePacket.readUInt16LE(3);\n          // 2 bytes per char, starting at offset 5\n          var server = routePacket.toString('ucs2', 5, 5 + serverLen * 2);\n\n          var newValue = {\n            protocol: protocol,\n            port: port,\n            server: server\n          };\n\n          parser.readUInt16LE(function (oldValueLength) {\n            parser.readBuffer(oldValueLength, function (oldValue) {\n              callback(newValue, oldValue);\n            });\n          });\n        });\n      });\n\n      break;\n\n    default:\n      console.error('Tedious > Unsupported ENVCHANGE type ' + type.name);\n      // skip unknown bytes\n      parser.readBuffer(length - 1, function () {\n        callback(undefined, undefined);\n      });\n  }\n}\n\nmodule.exports = function (parser, colMetadata, options, callback) {\n  parser.readUInt16LE(function (length) {\n    parser.readUInt8(function (typeNumber) {\n      var type = types[typeNumber];\n\n      if (!type) {\n        console.error('Tedious > Unsupported ENVCHANGE type ' + typeNumber);\n        // skip unknown bytes\n        return parser.readBuffer(length - 1, function () {\n          callback();\n        });\n      }\n\n      readNewAndOldValue(parser, length, type, function (newValue, oldValue) {\n        callback({\n          name: 'ENVCHANGE',\n          type: type.name,\n          event: type.event,\n          oldValue: oldValue,\n          newValue: newValue\n        });\n      });\n    });\n  });\n};","/home/travis/build/npmtest/node-npmtest-tedious/tedious/lib/token/infoerror-token-parser.js":"'use strict';\n\nfunction parseToken(parser, options, callback) {\n  // length\n  parser.readUInt16LE(function () {\n    parser.readUInt32LE(function (number) {\n      parser.readUInt8(function (state) {\n        parser.readUInt8(function (clazz) {\n          parser.readUsVarChar(function (message) {\n            parser.readBVarChar(function (serverName) {\n              parser.readBVarChar(function (procName) {\n                (options.tdsVersion < '7_2' ? parser.readUInt16LE : parser.readUInt32LE).call(parser, function (lineNumber) {\n                  callback({\n                    'number': number,\n                    'state': state,\n                    'class': clazz,\n                    'message': message,\n                    'serverName': serverName,\n                    'procName': procName,\n                    'lineNumber': lineNumber\n                  });\n                });\n              });\n            });\n          });\n        });\n      });\n    });\n  });\n}\n\nmodule.exports.infoParser = infoParser;\nfunction infoParser(parser, colMetadata, options, callback) {\n  parseToken(parser, options, function (token) {\n    token.name = 'INFO';\n    token.event = 'infoMessage';\n    callback(token);\n  });\n}\n\nmodule.exports.errorParser = errorParser;\nfunction errorParser(parser, colMetadata, options, callback) {\n  parseToken(parser, options, function (token) {\n    token.name = 'ERROR';\n    token.event = 'errorMessage';\n    callback(token);\n  });\n}","/home/travis/build/npmtest/node-npmtest-tedious/tedious/lib/token/loginack-token-parser.js":"'use strict';\n\nvar versions = require('../tds-versions').versionsByValue;\n\nvar interfaceTypes = {\n  0: 'SQL_DFLT',\n  1: 'SQL_TSQL'\n};\n\nmodule.exports = function (parser, colMetadata, options, callback) {\n  // length\n  parser.readUInt16LE(function () {\n    parser.readUInt8(function (interfaceNumber) {\n      var interfaceType = interfaceTypes[interfaceNumber];\n      parser.readUInt32BE(function (tdsVersionNumber) {\n        var tdsVersion = versions[tdsVersionNumber];\n        parser.readBVarChar(function (progName) {\n          parser.readUInt8(function (major) {\n            parser.readUInt8(function (minor) {\n              parser.readUInt8(function (buildNumHi) {\n                parser.readUInt8(function (buildNumLow) {\n                  callback({\n                    'name': 'LOGINACK',\n                    'event': 'loginack',\n                    'interface': interfaceType,\n                    'tdsVersion': tdsVersion,\n                    'progName': progName,\n                    'progVersion': {\n                      major: major,\n                      minor: minor,\n                      buildNumHi: buildNumHi,\n                      buildNumLow: buildNumLow\n                    }\n                  });\n                });\n              });\n            });\n          });\n        });\n      });\n    });\n  });\n};","/home/travis/build/npmtest/node-npmtest-tedious/tedious/lib/token/order-token-parser.js":"'use strict';\n\n// s2.2.7.14\n\nmodule.exports = function (parser, colMetadata, options, callback) {\n  parser.readUInt16LE(function (length) {\n    var columnCount = length / 2;\n    var orderColumns = [];\n\n    var i = 0;\n    function next(done) {\n      if (i === columnCount) {\n        return done();\n      }\n\n      parser.readUInt16LE(function (column) {\n        orderColumns.push(column);\n\n        i++;\n\n        next(done);\n      });\n    }\n\n    next(function () {\n      callback({\n        name: 'ORDER',\n        event: 'order',\n        orderColumns: orderColumns\n      });\n    });\n  });\n};","/home/travis/build/npmtest/node-npmtest-tedious/tedious/lib/token/returnstatus-token-parser.js":"'use strict';\n\n// s2.2.7.16\n\nmodule.exports = function (parser, colMetadata, options, callback) {\n  parser.readInt32LE(function (value) {\n    callback({\n      name: 'RETURNSTATUS',\n      event: 'returnStatus',\n      value: value\n    });\n  });\n};","/home/travis/build/npmtest/node-npmtest-tedious/tedious/lib/token/returnvalue-token-parser.js":"'use strict';\n\n// s2.2.7.16\n\nvar metadataParse = require('../metadata-parser');\nvar valueParse = require('../value-parser');\n\nmodule.exports = function (parser, colMetadata, options, callback) {\n  parser.readUInt16LE(function (paramOrdinal) {\n    parser.readBVarChar(function (paramName) {\n      if (paramName.charAt(0) === '@') {\n        paramName = paramName.slice(1);\n      }\n\n      // status\n      parser.readUInt8(function () {\n        metadataParse(parser, options, function (metadata) {\n          valueParse(parser, metadata, options, function (value) {\n            callback({\n              name: 'RETURNVALUE',\n              event: 'returnValue',\n              paramOrdinal: paramOrdinal,\n              paramName: paramName,\n              metadata: metadata,\n              value: value\n            });\n          });\n        });\n      });\n    });\n  });\n};","/home/travis/build/npmtest/node-npmtest-tedious/tedious/lib/value-parser.js":"'use strict';\n\nvar iconv = require('iconv-lite');\nvar sprintf = require('sprintf').sprintf;\nvar TYPE = require('./data-type').TYPE;\nvar guidParser = require('./guid-parser');\n\nvar readPrecision = require('./metadata-parser').readPrecision;\nvar readScale = require('./metadata-parser').readScale;\nvar readCollation = require('./metadata-parser').readCollation;\nvar convertLEBytesToString = require('./tracking-buffer/bigint').convertLEBytesToString;\n\nvar NULL = (1 << 16) - 1;\nvar MAX = (1 << 16) - 1;\nvar THREE_AND_A_THIRD = 3 + 1 / 3;\nvar MONEY_DIVISOR = 10000;\nvar PLP_NULL = new Buffer([0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]);\nvar UNKNOWN_PLP_LEN = new Buffer([0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]);\nvar DEFAULT_ENCODING = 'utf8';\n\nfunction readTextPointerNull(parser, type, callback) {\n  if (type.hasTextPointerAndTimestamp) {\n    parser.readUInt8(function (textPointerLength) {\n      if (textPointerLength !== 0) {\n        // Appear to be dummy values, so consume and discard them.\n        parser.readBuffer(textPointerLength, function () {\n          parser.readBuffer(8, function () {\n            callback(undefined);\n          });\n        });\n      } else {\n        callback(true);\n      }\n    });\n  } else {\n    callback(undefined);\n  }\n}\n\nfunction readDataLength(parser, type, metaData, textPointerNull, callback) {\n  if (textPointerNull) {\n    return callback(0);\n  }\n\n  if (metaData.isVariantValue) {\n    return callback(metaData.dataLength);\n  }\n\n  // s2.2.4.2.1\n  switch (type.id & 0x30) {\n    case 0x10:\n      // xx01xxxx - s2.2.4.2.1.1\n      return callback(0);\n\n    case 0x20:\n      // xx10xxxx - s2.2.4.2.1.3\n      // Variable length\n      if (metaData.dataLength !== MAX) {\n        switch (type.dataLengthLength) {\n          case 0:\n            return callback(undefined);\n\n          case 1:\n            return parser.readUInt8(callback);\n\n          case 2:\n            return parser.readUInt16LE(callback);\n\n          case 4:\n            return parser.readUInt32LE(callback);\n\n          default:\n            return parser.emit('error', new Error('Unsupported dataLengthLength ' + type.dataLengthLength + ' for data type ' + type.name));\n        }\n      } else {\n        return callback(undefined);\n      }\n\n    case 0x30:\n      return callback(1 << ((type.id & 0x0C) >> 2));\n  }\n}\n\nmodule.exports = valueParse;\nfunction valueParse(parser, metaData, options, callback) {\n  var type = metaData.type;\n\n  readTextPointerNull(parser, type, function (textPointerNull) {\n    readDataLength(parser, type, metaData, textPointerNull, function (dataLength) {\n      switch (type.name) {\n        case 'Null':\n          return callback(null);\n\n        case 'TinyInt':\n          return parser.readUInt8(callback);\n\n        case 'Int':\n          return parser.readInt32LE(callback);\n\n        case 'SmallInt':\n          return parser.readInt16LE(callback);\n\n        case 'BigInt':\n          return parser.readBuffer(8, function (buffer) {\n            callback(convertLEBytesToString(buffer));\n          });\n\n        case 'IntN':\n          switch (dataLength) {\n            case 0:\n              return callback(null);\n            case 1:\n              return parser.readUInt8(callback);\n            case 2:\n              return parser.readInt16LE(callback);\n            case 4:\n              return parser.readInt32LE(callback);\n            case 8:\n              return parser.readBuffer(8, function (buffer) {\n                callback(convertLEBytesToString(buffer));\n              });\n\n            default:\n              return parser.emit('error', new Error('Unsupported dataLength ' + dataLength + ' for IntN'));\n          }\n\n        case 'Real':\n          return parser.readFloatLE(callback);\n\n        case 'Float':\n          return parser.readDoubleLE(callback);\n\n        case 'FloatN':\n          switch (dataLength) {\n            case 0:\n              return callback(null);\n            case 4:\n              return parser.readFloatLE(callback);\n            case 8:\n              return parser.readDoubleLE(callback);\n\n            default:\n              return parser.emit('error', new Error('Unsupported dataLength ' + dataLength + ' for FloatN'));\n          }\n\n        case 'Money':\n        case 'SmallMoney':\n        case 'MoneyN':\n          switch (dataLength) {\n            case 0:\n              return callback(null);\n            case 4:\n              return parser.readInt32LE(function (value) {\n                callback(value / MONEY_DIVISOR);\n              });\n            case 8:\n              return parser.readInt32LE(function (high) {\n                parser.readUInt32LE(function (low) {\n                  callback((low + 0x100000000 * high) / MONEY_DIVISOR);\n                });\n              });\n\n            default:\n              return parser.emit('error', new Error('Unsupported dataLength ' + dataLength + ' for MoneyN'));\n          }\n\n        case 'Bit':\n          return parser.readUInt8(function (value) {\n            callback(!!value);\n          });\n\n        case 'BitN':\n          switch (dataLength) {\n            case 0:\n              return callback(null);\n            case 1:\n              return parser.readUInt8(function (value) {\n                callback(!!value);\n              });\n          }\n\n        case 'VarChar':\n        case 'Char':\n          var codepage = metaData.collation.codepage;\n          if (metaData.dataLength === MAX) {\n            return readMaxChars(parser, codepage, callback);\n          } else {\n            return readChars(parser, dataLength, codepage, callback);\n          }\n\n        case 'NVarChar':\n        case 'NChar':\n          if (metaData.dataLength === MAX) {\n            return readMaxNChars(parser, callback);\n          } else {\n            return readNChars(parser, dataLength, callback);\n          }\n\n        case 'VarBinary':\n        case 'Binary':\n          if (metaData.dataLength === MAX) {\n            return readMaxBinary(parser, callback);\n          } else {\n            return readBinary(parser, dataLength, callback);\n          }\n\n        case 'Text':\n          if (textPointerNull) {\n            return callback(null);\n          } else {\n            return readChars(parser, dataLength, metaData.collation.codepage, callback);\n          }\n\n        case 'NText':\n          if (textPointerNull) {\n            return callback(null);\n          } else {\n            return readNChars(parser, dataLength, callback);\n          }\n\n        case 'Image':\n          if (textPointerNull) {\n            return callback(null);\n          } else {\n            return readBinary(parser, dataLength, callback);\n          }\n\n        case 'Xml':\n          return readMaxNChars(parser, callback);\n\n        case 'SmallDateTime':\n          return readSmallDateTime(parser, options.useUTC, callback);\n\n        case 'DateTime':\n          return readDateTime(parser, options.useUTC, callback);\n\n        case 'DateTimeN':\n          switch (dataLength) {\n            case 0:\n              return callback(null);\n            case 4:\n              return readSmallDateTime(parser, options.useUTC, callback);\n            case 8:\n              return readDateTime(parser, options.useUTC, callback);\n          }\n\n        case 'TimeN':\n          if (dataLength === 0) {\n            return callback(null);\n          } else {\n            return readTime(parser, dataLength, metaData.scale, options.useUTC, callback);\n          }\n\n        case 'DateN':\n          if (dataLength === 0) {\n            return callback(null);\n          } else {\n            return readDate(parser, options.useUTC, callback);\n          }\n\n        case 'DateTime2N':\n          if (dataLength === 0) {\n            return callback(null);\n          } else {\n            return readDateTime2(parser, dataLength, metaData.scale, options.useUTC, callback);\n          }\n\n        case 'DateTimeOffsetN':\n          if (dataLength === 0) {\n            return callback(null);\n          } else {\n            return readDateTimeOffset(parser, dataLength, metaData.scale, callback);\n          }\n\n        case 'NumericN':\n        case 'DecimalN':\n          if (dataLength === 0) {\n            return callback(null);\n          } else {\n            return parser.readUInt8(function (sign) {\n              sign = sign === 1 ? 1 : -1;\n\n              var readValue = void 0;\n              switch (dataLength - 1) {\n                case 4:\n                  readValue = parser.readUInt32LE;\n                  break;\n                case 8:\n                  readValue = parser.readUNumeric64LE;\n                  break;\n                case 12:\n                  readValue = parser.readUNumeric96LE;\n                  break;\n                case 16:\n                  readValue = parser.readUNumeric128LE;\n                  break;\n                default:\n                  return parser.emit('error', new Error(sprintf('Unsupported numeric size %d', dataLength - 1)));\n              }\n\n              readValue.call(parser, function (value) {\n                callback(value * sign / Math.pow(10, metaData.scale));\n              });\n            });\n          }\n\n        case 'UniqueIdentifierN':\n          switch (dataLength) {\n            case 0:\n              return callback(null);\n            case 0x10:\n              return parser.readBuffer(0x10, function (data) {\n                callback(guidParser.arrayToGuid(data));\n              });\n\n            default:\n              return parser.emit('error', new Error(sprintf('Unsupported guid size %d', dataLength - 1)));\n          }\n\n        case 'UDT':\n          return readMaxBinary(parser, callback);\n\n        case 'Variant':\n          if (dataLength === 0) {\n            return callback(null);\n          }\n\n          var valueMetaData = metaData.valueMetaData = {};\n          Object.defineProperty(valueMetaData, 'isVariantValue', { value: true });\n          return parser.readUInt8(function (baseType) {\n            return parser.readUInt8(function (propBytes) {\n              valueMetaData.dataLength = dataLength - propBytes - 2;\n              valueMetaData.type = TYPE[baseType];\n              return readPrecision(parser, valueMetaData.type, function (precision) {\n                valueMetaData.precision = precision;\n                return readScale(parser, valueMetaData.type, function (scale) {\n                  valueMetaData.scale = scale;\n                  return readCollation(parser, valueMetaData.type, function (collation) {\n                    valueMetaData.collation = collation;\n                    if (baseType === 0xA5 || baseType === 0xAD || baseType === 0xA7 || baseType === 0xAF || baseType === 0xE7 || baseType === 0xEF) {\n                      return readDataLength(parser, valueMetaData.type, {}, null, function (maxDataLength) {\n                        valueMetaData.dataLength = maxDataLength;\n                        return valueParse(parser, valueMetaData, options, callback);\n                      });\n                    } else {\n                      return valueParse(parser, valueMetaData, options, callback);\n                    }\n                  });\n                });\n              });\n            });\n          });\n\n        default:\n          return parser.emit('error', new Error(sprintf('Unrecognised type %s', type.name)));\n      }\n    });\n  });\n}\n\nfunction readBinary(parser, dataLength, callback) {\n  if (dataLength === NULL) {\n    return callback(null);\n  } else {\n    return parser.readBuffer(dataLength, callback);\n  }\n}\n\nfunction readChars(parser, dataLength, codepage, callback) {\n  if (codepage == null) {\n    codepage = DEFAULT_ENCODING;\n  }\n\n  if (dataLength === NULL) {\n    return callback(null);\n  } else {\n    return parser.readBuffer(dataLength, function (data) {\n      callback(iconv.decode(data, codepage));\n    });\n  }\n}\n\nfunction readNChars(parser, dataLength, callback) {\n  if (dataLength === NULL) {\n    return callback(null);\n  } else {\n    return parser.readBuffer(dataLength, function (data) {\n      callback(data.toString('ucs2'));\n    });\n  }\n}\n\nfunction readMaxBinary(parser, callback) {\n  return readMax(parser, callback);\n}\n\nfunction readMaxChars(parser, codepage, callback) {\n  if (codepage == null) {\n    codepage = DEFAULT_ENCODING;\n  }\n\n  readMax(parser, function (data) {\n    if (data) {\n      callback(iconv.decode(data, codepage));\n    } else {\n      callback(null);\n    }\n  });\n}\n\nfunction readMaxNChars(parser, callback) {\n  readMax(parser, function (data) {\n    if (data) {\n      callback(data.toString('ucs2'));\n    } else {\n      callback(null);\n    }\n  });\n}\n\nfunction readMax(parser, callback) {\n  parser.readBuffer(8, function (type) {\n    if (type.equals(PLP_NULL)) {\n      return callback(null);\n    } else if (type.equals(UNKNOWN_PLP_LEN)) {\n      return readMaxUnknownLength(parser, callback);\n    } else {\n      var low = type.readUInt32LE(0);\n      var high = type.readUInt32LE(4);\n\n      if (high >= 2 << 53 - 32) {\n        console.warn('Read UInt64LE > 53 bits : high=' + high + ', low=' + low);\n      }\n\n      var expectedLength = low + 0x100000000 * high;\n      return readMaxKnownLength(parser, expectedLength, callback);\n    }\n  });\n}\n\nfunction readMaxKnownLength(parser, totalLength, callback) {\n  var data = new Buffer(totalLength);\n\n  var offset = 0;\n  function next(done) {\n    parser.readUInt32LE(function (chunkLength) {\n      if (!chunkLength) {\n        return done();\n      }\n\n      parser.readBuffer(chunkLength, function (chunk) {\n        chunk.copy(data, offset);\n        offset += chunkLength;\n\n        next(done);\n      });\n    });\n  }\n\n  next(function () {\n    if (offset !== totalLength) {\n      parser.emit('error', new Error('Partially Length-prefixed Bytes unmatched lengths : expected ' + totalLength + ', but got ' + offset + ' bytes'));\n    }\n\n    callback(data);\n  });\n}\n\nfunction readMaxUnknownLength(parser, callback) {\n  var chunks = [];\n\n  var length = 0;\n  function next(done) {\n    parser.readUInt32LE(function (chunkLength) {\n      if (!chunkLength) {\n        return done();\n      }\n\n      parser.readBuffer(chunkLength, function (chunk) {\n        chunks.push(chunk);\n        length += chunkLength;\n\n        next(done);\n      });\n    });\n  }\n\n  next(function () {\n    callback(Buffer.concat(chunks, length));\n  });\n}\n\nfunction readSmallDateTime(parser, useUTC, callback) {\n  parser.readUInt16LE(function (days) {\n    parser.readUInt16LE(function (minutes) {\n      var value = void 0;\n      if (useUTC) {\n        value = new Date(Date.UTC(1900, 0, 1));\n        value.setUTCDate(value.getUTCDate() + days);\n        value.setUTCMinutes(value.getUTCMinutes() + minutes);\n      } else {\n        value = new Date(1900, 0, 1);\n        value.setDate(value.getDate() + days);\n        value.setMinutes(value.getMinutes() + minutes);\n      }\n      callback(value);\n    });\n  });\n}\n\nfunction readDateTime(parser, useUTC, callback) {\n  parser.readInt32LE(function (days) {\n    parser.readUInt32LE(function (threeHundredthsOfSecond) {\n      var milliseconds = Math.round(threeHundredthsOfSecond * THREE_AND_A_THIRD);\n\n      var value = void 0;\n      if (useUTC) {\n        value = new Date(Date.UTC(1900, 0, 1));\n        value.setUTCDate(value.getUTCDate() + days);\n        value.setUTCMilliseconds(value.getUTCMilliseconds() + milliseconds);\n      } else {\n        value = new Date(1900, 0, 1);\n        value.setDate(value.getDate() + days);\n        value.setMilliseconds(value.getMilliseconds() + milliseconds);\n      }\n\n      callback(value);\n    });\n  });\n}\n\nfunction readTime(parser, dataLength, scale, useUTC, callback) {\n  var readValue = void 0;\n  switch (dataLength) {\n    case 3:\n      readValue = parser.readUInt24LE;\n      break;\n    case 4:\n      readValue = parser.readUInt32LE;\n      break;\n    case 5:\n      readValue = parser.readUInt40LE;\n  }\n\n  readValue.call(parser, function (value) {\n    if (scale < 7) {\n      for (var i = scale; i < 7; i++) {\n        value *= 10;\n      }\n    }\n\n    var date = void 0;\n    if (useUTC) {\n      date = new Date(Date.UTC(1970, 0, 1, 0, 0, 0, value / 10000));\n    } else {\n      date = new Date(1970, 0, 1, 0, 0, 0, value / 10000);\n    }\n    Object.defineProperty(date, 'nanosecondsDelta', {\n      enumerable: false,\n      value: value % 10000 / Math.pow(10, 7)\n    });\n    callback(date);\n  });\n}\n\nfunction readDate(parser, useUTC, callback) {\n  parser.readUInt24LE(function (days) {\n    if (useUTC) {\n      callback(new Date(Date.UTC(2000, 0, days - 730118)));\n    } else {\n      callback(new Date(2000, 0, days - 730118));\n    }\n  });\n}\n\nfunction readDateTime2(parser, dataLength, scale, useUTC, callback) {\n  readTime(parser, dataLength - 3, scale, useUTC, function (time) {\n    parser.readUInt24LE(function (days) {\n      var date = void 0;\n      if (useUTC) {\n        date = new Date(Date.UTC(2000, 0, days - 730118, 0, 0, 0, +time));\n      } else {\n        date = new Date(2000, 0, days - 730118, time.getHours(), time.getMinutes(), time.getSeconds(), time.getMilliseconds());\n      }\n      Object.defineProperty(date, 'nanosecondsDelta', {\n        enumerable: false,\n        value: time.nanosecondsDelta\n      });\n      callback(date);\n    });\n  });\n}\n\nfunction readDateTimeOffset(parser, dataLength, scale, callback) {\n  readTime(parser, dataLength - 5, scale, true, function (time) {\n    parser.readUInt24LE(function (days) {\n      // offset\n      parser.readInt16LE(function () {\n        var date = new Date(Date.UTC(2000, 0, days - 730118, 0, 0, 0, +time));\n        Object.defineProperty(date, 'nanosecondsDelta', {\n          enumerable: false,\n          value: time.nanosecondsDelta\n        });\n        callback(date);\n      });\n    });\n  });\n}","/home/travis/build/npmtest/node-npmtest-tedious/tedious/lib/token/row-token-parser.js":"'use strict';\n\n// s2.2.7.17\n\nvar valueParse = require('../value-parser');\n\nmodule.exports = function (parser, colMetadata, options, callback) {\n  var columns = options.useColumnNames ? {} : [];\n\n  var len = colMetadata.length;\n  var i = 0;\n\n  function next(done) {\n    if (i === len) {\n      return done();\n    }\n\n    var columnMetaData = colMetadata[i];\n    valueParse(parser, columnMetaData, options, function (value) {\n      var column = {\n        value: value,\n        metadata: columnMetaData\n      };\n\n      if (options.useColumnNames) {\n        if (columns[columnMetaData.colName] == null) {\n          columns[columnMetaData.colName] = column;\n        }\n      } else {\n        columns.push(column);\n      }\n\n      i++;\n\n      next(done);\n    });\n  }\n\n  next(function () {\n    callback({\n      name: 'ROW',\n      event: 'row',\n      columns: columns\n    });\n  });\n};","/home/travis/build/npmtest/node-npmtest-tedious/tedious/lib/token/nbcrow-token-parser.js":"'use strict';\n\n// s2.2.7.13 (introduced in TDS 7.3.B)\n\nvar valueParse = require('../value-parser');\n\nfunction nullHandler(parser, columnMetaData, options, callback) {\n  callback(null);\n}\n\nmodule.exports = function (parser, columnsMetaData, options, callback) {\n  var length = Math.ceil(columnsMetaData.length / 8);\n  parser.readBuffer(length, function (bytes) {\n    var bitmap = [];\n\n    for (var _i = 0, _len = bytes.length; _i < _len; _i++) {\n      var byte = bytes[_i];\n      for (var j = 0; j <= 7; j++) {\n        bitmap.push(byte & 1 << j ? true : false);\n      }\n    }\n\n    var columns = options.useColumnNames ? {} : [];\n\n    var len = columnsMetaData.length;\n    var i = 0;\n    function next(done) {\n      if (i === len) {\n        return done();\n      }\n\n      var columnMetaData = columnsMetaData[i];\n\n      (bitmap[i] ? nullHandler : valueParse)(parser, columnMetaData, options, function (value) {\n        var column = {\n          value: value,\n          metadata: columnMetaData\n        };\n\n        if (options.useColumnNames) {\n          if (columns[columnMetaData.colName] == null) {\n            columns[columnMetaData.colName] = column;\n          }\n        } else {\n          columns.push(column);\n        }\n\n        i++;\n        next(done);\n      });\n    }\n\n    next(function () {\n      callback({\n        name: 'NBCROW',\n        event: 'row',\n        columns: columns\n      });\n    });\n  });\n};","/home/travis/build/npmtest/node-npmtest-tedious/tedious/lib/token/sspi-token-parser.js":"'use strict';\n\nfunction parseChallenge(buffer) {\n  var challenge = {};\n  challenge.magic = buffer.slice(0, 8).toString('utf8');\n  challenge.type = buffer.readInt32LE(8);\n  challenge.domainLen = buffer.readInt16LE(12);\n  challenge.domainMax = buffer.readInt16LE(14);\n  challenge.domainOffset = buffer.readInt32LE(16);\n  challenge.flags = buffer.readInt32LE(20);\n  challenge.nonce = buffer.slice(24, 32);\n  challenge.zeroes = buffer.slice(32, 40);\n  challenge.targetLen = buffer.readInt16LE(40);\n  challenge.targetMax = buffer.readInt16LE(42);\n  challenge.targetOffset = buffer.readInt32LE(44);\n  challenge.oddData = buffer.slice(48, 56);\n  challenge.domain = buffer.slice(56, 56 + challenge.domainLen).toString('ucs2');\n  challenge.target = buffer.slice(56 + challenge.domainLen, 56 + challenge.domainLen + challenge.targetLen);\n  return challenge;\n}\n\nmodule.exports = function (parser, colMetadata, options, callback) {\n  parser.readUsVarByte(function (buffer) {\n    callback({\n      name: 'SSPICHALLENGE',\n      event: 'sspichallenge',\n      ntlmpacket: parseChallenge(buffer)\n    });\n  });\n};","/home/travis/build/npmtest/node-npmtest-tedious/tedious/lib/transaction.js":"'use strict';\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar WritableTrackingBuffer = require('./tracking-buffer/writable-tracking-buffer');\nvar writeAllHeaders = require('./all-headers').writeToTrackingBuffer;\n\n/*\n  s2.2.6.8\n */\n\nvar OPERATION_TYPE = module.exports.OPERATION_TYPE = {\n  TM_GET_DTC_ADDRESS: 0x00,\n  TM_PROPAGATE_XACT: 0x01,\n  TM_BEGIN_XACT: 0x05,\n  TM_PROMOTE_XACT: 0x06,\n  TM_COMMIT_XACT: 0x07,\n  TM_ROLLBACK_XACT: 0x08,\n  TM_SAVE_XACT: 0x09\n};\n\nvar ISOLATION_LEVEL = module.exports.ISOLATION_LEVEL = {\n  NO_CHANGE: 0x00,\n  READ_UNCOMMITTED: 0x01,\n  READ_COMMITTED: 0x02,\n  REPEATABLE_READ: 0x03,\n  SERIALIZABLE: 0x04,\n  SNAPSHOT: 0x05\n};\n\nvar isolationLevelByValue = {};\nfor (var name in ISOLATION_LEVEL) {\n  var value = ISOLATION_LEVEL[name];\n  isolationLevelByValue[value] = name;\n}\n\nvar Transaction = function () {\n  function Transaction(name, isolationLevel) {\n    (0, _classCallCheck3.default)(this, Transaction);\n\n    this.name = name;\n    this.isolationLevel = isolationLevel;\n    this.outstandingRequestCount = 1;\n  }\n\n  (0, _createClass3.default)(Transaction, [{\n    key: 'beginPayload',\n    value: function beginPayload(txnDescriptor) {\n      var _this = this;\n\n      var buffer = new WritableTrackingBuffer(100, 'ucs2');\n      writeAllHeaders(buffer, txnDescriptor, this.outstandingRequestCount);\n      buffer.writeUShort(OPERATION_TYPE.TM_BEGIN_XACT);\n      buffer.writeUInt8(this.isolationLevel);\n      buffer.writeUInt8(this.name.length * 2);\n      buffer.writeString(this.name, 'ucs2');\n\n      return {\n        data: buffer.data,\n        toString: function toString() {\n          return 'Begin Transaction: name=' + _this.name + ', isolationLevel=' + isolationLevelByValue[_this.isolationLevel];\n        }\n      };\n    }\n  }, {\n    key: 'commitPayload',\n    value: function commitPayload(txnDescriptor) {\n      var _this2 = this;\n\n      var buffer = new WritableTrackingBuffer(100, 'ascii');\n      writeAllHeaders(buffer, txnDescriptor, this.outstandingRequestCount);\n      buffer.writeUShort(OPERATION_TYPE.TM_COMMIT_XACT);\n      buffer.writeUInt8(this.name.length * 2);\n      buffer.writeString(this.name, 'ucs2');\n      // No fBeginXact flag, so no new transaction is started.\n      buffer.writeUInt8(0);\n\n      return {\n        data: buffer.data,\n        toString: function toString() {\n          return 'Commit Transaction: name=' + _this2.name;\n        }\n      };\n    }\n  }, {\n    key: 'rollbackPayload',\n    value: function rollbackPayload(txnDescriptor) {\n      var _this3 = this;\n\n      var buffer = new WritableTrackingBuffer(100, 'ascii');\n      writeAllHeaders(buffer, txnDescriptor, this.outstandingRequestCount);\n      buffer.writeUShort(OPERATION_TYPE.TM_ROLLBACK_XACT);\n      buffer.writeUInt8(this.name.length * 2);\n      buffer.writeString(this.name, 'ucs2');\n      // No fBeginXact flag, so no new transaction is started.\n      buffer.writeUInt8(0);\n\n      return {\n        data: buffer.data,\n        toString: function toString() {\n          return 'Rollback Transaction: name=' + _this3.name;\n        }\n      };\n    }\n  }, {\n    key: 'savePayload',\n    value: function savePayload(txnDescriptor) {\n      var _this4 = this;\n\n      var buffer = new WritableTrackingBuffer(100, 'ascii');\n      writeAllHeaders(buffer, txnDescriptor, this.outstandingRequestCount);\n      buffer.writeUShort(OPERATION_TYPE.TM_SAVE_XACT);\n      buffer.writeUInt8(this.name.length * 2);\n      buffer.writeString(this.name, 'ucs2');\n\n      return {\n        data: buffer.data,\n        toString: function toString() {\n          return 'Save Transaction: name=' + _this4.name;\n        }\n      };\n    }\n  }, {\n    key: 'isolationLevelToTSQL',\n    value: function isolationLevelToTSQL() {\n      switch (this.isolationLevel) {\n        case ISOLATION_LEVEL.READ_UNCOMMITTED:\n          return 'READ UNCOMMITTED';\n        case ISOLATION_LEVEL.READ_COMMITTED:\n          return 'READ COMMITTED';\n        case ISOLATION_LEVEL.REPEATABLE_READ:\n          return 'REPEATABLE READ';\n        case ISOLATION_LEVEL.SERIALIZABLE:\n          return 'SERIALIZABLE';\n        case ISOLATION_LEVEL.SNAPSHOT:\n          return 'SNAPSHOT';\n      }\n      return '';\n    }\n  }]);\n  return Transaction;\n}();\n\nmodule.exports.Transaction = Transaction;","/home/travis/build/npmtest/node-npmtest-tedious/tedious/lib/connector.js":"'use strict';\n\nvar _create = require('babel-runtime/core-js/object/create');\n\nvar _create2 = _interopRequireDefault(_create);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar net = require('net');\nvar dns = require('dns');\n\nvar Connector = function () {\n  function Connector(options, multiSubnetFailover) {\n    (0, _classCallCheck3.default)(this, Connector);\n\n    this.options = options;\n    this.multiSubnetFailover = multiSubnetFailover;\n  }\n\n  (0, _createClass3.default)(Connector, [{\n    key: 'execute',\n    value: function execute(cb) {\n      if (net.isIP(this.options.host)) {\n        this.executeForIP(cb);\n      } else {\n        this.executeForHostname(cb);\n      }\n    }\n  }, {\n    key: 'executeForIP',\n    value: function executeForIP(cb) {\n      var socket = net.connect(this.options);\n\n      var onError = function onError(err) {\n        socket.removeListener('error', onError);\n        socket.removeListener('connect', onConnect);\n\n        socket.destroy();\n\n        cb(err);\n      };\n\n      var onConnect = function onConnect() {\n        socket.removeListener('error', onError);\n        socket.removeListener('connect', onConnect);\n\n        cb(null, socket);\n      };\n\n      socket.on('error', onError);\n      socket.on('connect', onConnect);\n    }\n  }, {\n    key: 'executeForHostname',\n    value: function executeForHostname(cb) {\n      var _this = this;\n\n      dns.lookup(this.options.host, { all: true }, function (err, addresses) {\n        if (err) {\n          return cb(err);\n        }\n\n        if (_this.multiSubnetFailover) {\n          new ParallelConnectionStrategy(addresses, _this.options).connect(cb);\n        } else {\n          new SequentialConnectionStrategy(addresses, _this.options).connect(cb);\n        }\n      });\n    }\n  }]);\n  return Connector;\n}();\n\nvar ParallelConnectionStrategy = function () {\n  function ParallelConnectionStrategy(addresses, options) {\n    (0, _classCallCheck3.default)(this, ParallelConnectionStrategy);\n\n    this.addresses = addresses;\n    this.options = options;\n  }\n\n  (0, _createClass3.default)(ParallelConnectionStrategy, [{\n    key: 'connect',\n    value: function connect(callback) {\n      var addresses = this.addresses;\n      var sockets = new Array(addresses.length);\n\n      var errorCount = 0;\n      var onError = function onError(err) {\n        errorCount += 1;\n\n        this.removeListener('error', onError);\n        this.removeListener('connect', onConnect);\n\n        if (errorCount === addresses.length) {\n          callback(new Error('Could not connect (parallel)'));\n        }\n      };\n\n      var onConnect = function onConnect() {\n        for (var j = 0; j < sockets.length; j++) {\n          var socket = sockets[j];\n\n          if (this === socket) {\n            continue;\n          }\n\n          socket.removeListener('error', onError);\n          socket.removeListener('connect', onConnect);\n          socket.destroy();\n        }\n\n        callback(null, this);\n      };\n\n      for (var i = 0, len = addresses.length; i < len; i++) {\n        var socket = sockets[i] = net.connect((0, _create2.default)(this.options, {\n          host: { value: addresses[i].address }\n        }));\n\n        socket.on('error', onError);\n        socket.on('connect', onConnect);\n      }\n    }\n  }]);\n  return ParallelConnectionStrategy;\n}();\n\nvar SequentialConnectionStrategy = function () {\n  function SequentialConnectionStrategy(addresses, options) {\n    (0, _classCallCheck3.default)(this, SequentialConnectionStrategy);\n\n    this.addresses = addresses;\n    this.options = options;\n  }\n\n  (0, _createClass3.default)(SequentialConnectionStrategy, [{\n    key: 'connect',\n    value: function connect(callback) {\n      var _this2 = this;\n\n      var addresses = this.addresses;\n\n      if (!addresses.length) {\n        callback(new Error('Could not connect (sequence)'));\n        return;\n      }\n\n      var next = addresses.shift();\n\n      var socket = net.connect((0, _create2.default)(this.options, {\n        host: { value: next.address }\n      }));\n\n      var onError = function onError(err) {\n        socket.removeListener('error', onError);\n        socket.removeListener('connect', onConnect);\n\n        socket.destroy();\n\n        _this2.connect(callback);\n      };\n\n      var onConnect = function onConnect() {\n        socket.removeListener('error', onError);\n        socket.removeListener('connect', onConnect);\n\n        callback(null, socket);\n      };\n\n      socket.on('error', onError);\n      socket.on('connect', onConnect);\n    }\n  }]);\n  return SequentialConnectionStrategy;\n}();\n\nmodule.exports.Connector = Connector;\nmodule.exports.ParallelConnectionStrategy = ParallelConnectionStrategy;\nmodule.exports.SequentialConnectionStrategy = SequentialConnectionStrategy;"}